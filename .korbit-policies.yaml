version: '0.1'
topics:
  - name: "4.1. The implementation"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Dir 1.1. Any implementation-defined behaviour on which the output of the program depends shall be indicated with code annotations"
        description: |
          Any implementation-defined behaviour on which the output of the program depends shall be clearly indicated with standardized code comments or annotations. This includes core behaviours, extensions, standard library aspects, ABI details, and floating-point implementation characteristics.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Ensures that program output is intentional and not produced by chance. Implementation-defined behaviour without clear code annotations can lead to unexpected program operation and portability issues across different implementations.
        code_examples:
          # C examples
          - non_compliant: |
              void main(void) {  // Implementation-defined return type - not annotated
                  int x = -5 / 2;  // Implementation-defined rounding in C90 - not annotated
              }

          - compliant: |
              /* IMPL_BEHAVIOR: void main() used for freestanding environment */
              /* IMPL_BEHAVIOR: Signed division rounds towards zero (C99+ behavior) */
              void main(void) {
                  int x = -5 / 2;  /* IMPL_BEHAVIOR: Result: -2 (towards zero rounding) */
              }

      - title: "Dir 1.2. The use of language extensions should be minimized and annotated"
        description: |
          Language extensions should be minimized. When extensions are used, their use must be justified with inline code comments explaining the necessity and expected behavior.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Programs relying on language extensions may be less portable and may not fully describe behavior in all circumstances without proper inline justification. Extensions that alter strictly conforming program behavior violate the C Standard.
        code_examples:
          # C examples
          - non_compliant: |
              __attribute__((packed)) struct data {  // Compiler-specific extension used without justification
                  char a;
                  int b;
              };

          - compliant: |
              /* EXTENSION_JUSTIFIED: Packed structure needed for hardware interface protocol */
              /* EXTENSION_BEHAVIOR: Using GCC __attribute__((packed)) extension for memory layout control */
              __attribute__((packed)) struct data {
                  char a;
                  int b;
              };

  - name: "4.2. Compilation and build"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Dir 2.1. All source files shall compile without any compilation errors"
        description: |
          All source files shall compile without any compilation errors.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          A conforming compiler is permitted to produce an object module despite the presence of compilation errors. However, execution of the resulting program may produce unexpected behavior.
        code_examples:
          # C examples
          - non_compliant: |
              // Compilation error: missing semicolon
              #include <stdio.h>
              
              int main(void)
              {
                  int x = 5  // Missing semicolon causes compilation error
                  printf("Value: %d\n", x);
                  return 0;
              }

          - compliant: |
              // Compiles without errors
              #include <stdio.h>
              
              int main(void)
              {
                  int x = 5;  // Proper syntax with semicolon
                  printf("Value: %d\n", x);
                  return 0;
              }

  - name: "4.3. Requirements traceability"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Dir 3.1. All code shall be traceable to documented requirements"
        description: |
          All code shall be traceable to documented requirements.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Functionality that is not needed to meet project requirements gives rise to unnecessary execution paths. Developers might not be aware of the wider implications that might arise from additional functionality.
        code_examples:
          # C examples
          - non_compliant: |
              void process_data(int data) {
                  toggle_debug_pin();  // No traceability to requirements
                  // ... actual processing
              }

          - compliant: |
              /* TRACE: REQ-001 - Data processing function for sensor validation */
              void process_data(int data) {
                  /* TRACE: REQ-002 - Debug output for timing analysis */
                  toggle_debug_pin();
                  // ... processing logic
              }

  - name: "4.4. Code design"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Dir 4.1a. Arithmetic errors and division by zero shall be prevented"
        description: |
          Arithmetic operations shall be protected against overflow, underflow, and division by zero through appropriate checks and careful expression ordering.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Arithmetic errors can cause undefined behavior, unexpected results, or system failures. Division by zero and overflow conditions must be detected before they occur.
        code_examples:
          # C examples
          - non_compliant: |
              int32_t divide_values(int32_t a, int32_t b) {
                  return a / b;  // No check for division by zero
              }
              uint32_t add_values(uint32_t a, uint32_t b) {
                  return a + b;  // No overflow check
              }

          - compliant: |
              int32_t divide_values(int32_t a, int32_t b) {
                  if (b != 0) {
                      return a / b;  // Division by zero prevented
                  }
                  return 0;  // Safe fallback
              }
              uint32_t add_values(uint32_t a, uint32_t b) {
                  if (a <= UINT32_MAX - b) {
                      return a + b;  // Overflow prevented
                  }
                  return UINT32_MAX;  // Safe saturation
              }

      - title: "Dir 4.1b. Array bounds violations shall be prevented"
        description: |
          Array indices shall be validated to ensure they remain within the bounds of the array before accessing array elements.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Array bounds violations can cause buffer overruns, memory corruption, and security vulnerabilities. Bounds checking is essential for safe array access.
        code_examples:
          # C examples
          - non_compliant: |
              void process_array(int32_t arr[], int32_t index) {
                  int32_t value = arr[index];  // No bounds checking
                  arr[index] = value * 2;
              }

          - compliant: |
              void process_array(int32_t arr[], int32_t index, int32_t size) {
                  if (index >= 0 && index < size) {
                      int32_t value = arr[index];  // Bounds checked
                      arr[index] = value * 2;
                  }
              }

      - title: "Dir 4.1c. NULL pointer dereference shall be prevented"
        description: |
          Pointers shall be checked for NULL before dereferencing.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Dereferencing NULL pointers causes undefined behavior and typically results in segmentation faults or system crashes. NULL checks are essential for robust pointer operations.
        code_examples:
          # C examples
          - non_compliant: |
              void process_data(int32_t *ptr) {
                  *ptr = 42;  // No NULL check
                  int32_t value = *ptr;
              }

          - compliant: |
              void process_data(int32_t *ptr) {
                  if (ptr != NULL) {
                      *ptr = 42;  // NULL check performed
                      int32_t value = *ptr;
                  }
              }

      - title: "Dir 4.1d. Function parameters shall be validated"
        description: |
          Function parameters shall be validated for correctness and safety before use within the function body.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Invalid function parameters can lead to undefined behavior, incorrect calculations, or system failures. Parameter validation ensures functions operate within expected constraints.
        code_examples:
          # C examples
          - non_compliant: |
              uint32_t calculate_factorial(int32_t n) {
                  uint32_t result = 1;
                  for (int32_t i = 1; i <= n; i++) {  // No validation of n
                      result *= i;
                  }
                  return result;
              }

          - compliant: |
              uint32_t calculate_factorial(int32_t n) {
                  if (n < 0 || n > 12) {  // Parameter validation
                      return 0;  // Invalid input
                  }
                  uint32_t result = 1;
                  for (int32_t i = 1; i <= n; i++) {
                      result *= i;
                  }
                  return result;
              }

      - title: "Dir 4.2. All usage of assembly language should be documented"
        description: |
          Assembly language usage shall be preceded by comments that document the purpose and interface mechanism. Comments must follow a standardized format that can be programmatically verified.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Assembly language code is implementation-defined and not portable. Standardized documentation comments ensure maintainability and provide necessary context for understanding the assembly code purpose.
        code_examples:
          # C examples
          - non_compliant: |
              void critical_section(void) {
                  asm("cli");  // Missing documentation format
                  // critical code
                  asm("sti");
              }

          - compliant: |
              void critical_section(void) {
                  /* ASM_PURPOSE: Disable interrupts for atomic operation */
                  /* ASM_INTERFACE: Inline assembly with GCC syntax */
                  asm("cli");  // Disable interrupts
                  // critical code
                  asm("sti");  // Re-enable interrupts
              }

      - title: "Dir 4.3. Assembly language shall be encapsulated and isolated"
        description: |
          Assembly language instructions shall be encapsulated and isolated in assembly language functions, C functions (inline functions preferred for C99+), or C macros.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Encapsulation improves readability, makes intent clear through naming, enables code reuse, and allows easy substitution for different targets or static analysis.
        code_examples:
          # C examples
          - non_compliant: |
              void process_data(void) {
                  // processing code
                  asm(" NOP");  // Inline assembly not encapsulated
                  // more processing
              }

          - compliant: |
              #define NOP() asm(" NOP")
              void process_data(void) {
                  // processing code
                  NOP();  // Assembly encapsulated in macro
                  // more processing
              }

      - title: "Dir 4.4. Sections of code should not be \"commented out\""
        description: |
          Sections of code should not be "commented out" using comment markers. Use conditional compilation constructs instead when code should not be compiled.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using comment markers is dangerous because C does not support nested comments. Existing comments in the commented-out section would change the effect and potentially cause compilation errors.
        code_examples:
          # C examples
          - non_compliant: |
              void function(void) {
                  int x = 5;
                  /*
                  int y = 10;  // This comment breaks the outer comment
                  process(y);
                  */
              }

          - compliant: |
              void function(void) {
                  int x = 5;
              #if 0  /* Debugging code temporarily disabled */
                  int y = 10;  // This comment is safe
                  process(y);
              #endif
              }

      - title: "Dir 4.5. Identifiers in the same name space with overlapping visibility should be typographically unambiguous"
        description: |
          Identifiers should be typographically unambiguous. They should not differ only by case, underscores, or visually similar characters like O/0, I/l/1, S/5, Z/2, B/8, rn/m.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Visually similar identifiers can lead to developer confusion and bugs. Depending on the font used, certain characters may appear identical even though they are different.
        code_examples:
          # C examples
          - non_compliant: |
              int32_t id1_abc;
              int32_t id1_ABC;  // Differs only by case
              int32_t id2_O;
              int32_t id2_0;    // O vs digit 0

          - compliant: |
              int32_t identifier_abc;
              int32_t identifier_xyz;  // Clearly different
              int32_t letter_O;
              int32_t digit_zero;      // Unambiguous naming

      - title: "Dir 4.6. typedefs that indicate size and signedness should be used in place of the basic integer types"
        description: |
          Specific-length typedefs (like int32_t, uint16_t) should be used instead of basic integer types (int, short, long). For C99+, use types from stdint.h.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Specific-length types make memory allocation requirements clear and improve portability by explicitly specifying the intended size and signedness of variables.
        code_examples:
          # C examples
          - non_compliant: |
              int counter = 0;           // Basic type, size unclear
              unsigned long address;     // Implementation-dependent size

          - compliant: |
              int32_t counter = 0;       // Explicit 32-bit signed
              uint64_t address;          // Explicit 64-bit unsigned

      - title: "Dir 4.7. If a function returns error information, then that error information shall be tested"
        description: |
          Error information returned by functions shall be tested in a meaningful manner.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Ignoring error information can lead to unexpected program behavior, data corruption, or system failures. Testing error conditions enables proper error handling and recovery.
        code_examples:
          # C examples
          - non_compliant: |
              FILE *fp;
              char buffer[100];
              fp = fopen("file.txt", "r");  // Error return not tested
              fread(buffer, 1, 100, fp);    // Could fail if fopen failed

          - compliant: |
              FILE *fp;
              char buffer[100];
              fp = fopen("file.txt", "r");
              if (fp != NULL) {             // Error information tested
                  fread(buffer, 1, 100, fp);
                  fclose(fp);               // Properly close the file
              }

      - title: "Dir 4.8. If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden"
        description: |
          When pointers to structures or unions are never dereferenced in a translation unit, the implementation should be hidden using incomplete types to create opaque types.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Hiding implementation details protects against unintentional changes and creates better encapsulation. Opaque types can be referenced via pointers but their contents cannot be accessed.
        code_examples:
          # C examples
          - non_compliant: |
              // myobject.h - Header unnecessarily exposes implementation
              typedef struct {
                  int internal_data;
                  char status;
              } MyObject;
              void process_object(MyObject *obj);
              void cleanup_object(MyObject *obj);
              
              // client.c - Pointers used but never dereferenced
              void client_code(void) {
                  MyObject *obj = get_object();
                  process_object(obj);      // Only pass pointer, never dereference
                  cleanup_object(obj);      // Only pass pointer, never dereference
              }

          - compliant: |
              // myobject.h - Header hides implementation using incomplete type
              typedef struct MyObject MyObject;  // Incomplete type declaration
              typedef MyObject *pMyObject;
              pMyObject get_object(void);
              void process_object(pMyObject obj);
              void cleanup_object(pMyObject obj);
              
              // myobject.c - Implementation details hidden
              struct MyObject {
                  int internal_data;  // Hidden from clients
                  char status;
              };
              
              // client.c - Uses opaque pointers safely
              void client_code(void) {
                  pMyObject obj = get_object();
                  process_object(obj);      // Pass opaque pointer
                  cleanup_object(obj);      // Pass opaque pointer
              }

      - title: "Dir 4.9. A function should be used in preference to a function-like macro where they are interchangeable"
        description: |
          Functions should be preferred over function-like macros when they are interchangeable.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Functions provide better type safety, avoid multiple evaluation of arguments with side effects, and are easier to debug. Macros should only be used when functions cannot achieve the same result.
        code_examples:
          # C examples
          - non_compliant: |
              #define MAX(a, b) ((a) > (b) ? (a) : (b))
              int result = MAX(++x, y);  // x incremented twice if x > y

          - compliant: |
              static inline int max(int a, int b) {
                  return (a > b) ? a : b;
              }
              int result = max(++x, y);  // x incremented only once

      - title: "Dir 4.10. Precautions shall be taken in order to prevent the contents of a header file being included more than once"
        description: |
          Header files must be protected against multiple inclusion using include guards or similar mechanisms. Guard identifiers must be unique across all header files in the project.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Multiple inclusion of header files can cause confusion, multiple definitions, and undefined behavior. Include guards prevent these issues by ensuring header contents are processed only once per translation unit.
        code_examples:
          # C examples
          - non_compliant: |
              /* file.h - no include guard */
              typedef struct {
                  int data;
              } MyStruct;
              void my_function(void);

          - compliant: |
              /* file.h - proper include guard */
              #ifndef FILE_H
              #define FILE_H
              typedef struct {
                  int data;
              } MyStruct;
              void my_function(void);
              #endif

      - title: "Dir 4.11. The validity of values passed to library functions shall be checked"
        description: |
          Input values to library functions must be validated before use. Many standard library functions do not check parameter validity and can exhibit undefined behavior with invalid inputs.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Invalid parameters to library functions can cause undefined behavior, crashes, or security vulnerabilities. Standard library functions often assume valid inputs and provide no error checking.
        code_examples:
          # C examples
          - non_compliant: |
              #include <math.h>
              double result = sqrt(x);        // No check for negative x
              int upper = toupper(c);         // No validation of c

          - compliant: |
              #include <math.h>
              double result = 0.0;
              if (x >= 0.0) {
                  result = sqrt(x);           // Check for non-negative input
              }
              if (isalpha(c)) {
                  int upper = toupper(c);     // Validate input character
              }

      - title: "Dir 4.12. Dynamic memory allocation shall not be used"
        description: |
          Dynamic memory allocation shall not be used, including standard library functions and third-party packages. This applies to malloc, calloc, realloc, free, and similar functions.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Dynamic memory allocation can lead to undefined behavior, allocation failures, memory fragmentation, and unpredictable execution times. These issues are particularly problematic in safety-critical systems.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdlib.h>
              void process_data(void) {
                  char *buffer = malloc(100);  // Dynamic allocation
                  // ... use buffer
                  free(buffer);
              }

          - compliant: |
              void process_data(void) {
                  char buffer[100];           // Static allocation
                  // ... use buffer
                  // No need to free
              }

      - title: "Dir 4.13a. Memory allocation and deallocation functions shall be called in appropriate sequence"
        description: |
          Memory allocation functions (malloc, calloc, realloc) and deallocation functions (free) shall be called in proper sequence with matching pairs and proper error handling.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: multi-file
        severity: mandatory
        impact: |
          Improper memory management sequences can lead to memory leaks, double-free errors, or use-after-free vulnerabilities. All allocation paths must have corresponding deallocation paths.
        code_examples:
          # C examples
          - non_compliant: |
              void process_data(void) {
                  char *buffer = malloc(100);
                  if (some_condition) {
                      return;  // Memory leak - buffer not freed
                  }
                  free(buffer);
              }

          - compliant: |
              void process_data(void) {
                  char *buffer = malloc(100);
                  if (buffer != NULL) {
                      if (some_condition) {
                          free(buffer);  // Proper cleanup
                          return;
                      }
                      free(buffer);      // Proper cleanup
                  }
              }

      - title: "Dir 4.13b. File operations shall be called in appropriate sequence"
        description: |
          File opening functions (fopen, freopen) and closing functions (fclose) shall be called in proper sequence with matching pairs and proper error handling.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: multi-file
        severity: mandatory
        impact: |
          Improper file operation sequences can lead to file handle leaks, resource exhaustion, or data corruption. All file opening operations must have corresponding closing operations.
        code_examples:
          # C examples
          - non_compliant: |
              void process_file(void) {
                  FILE *fp = fopen("data.txt", "r");
                  if (some_condition) {
                      return;  // File not closed on this path
                  }
                  fclose(fp);
              }

          - compliant: |
              void process_file(void) {
                  FILE *fp = fopen("data.txt", "r");
                  if (fp != NULL) {
                      if (some_condition) {
                          fclose(fp);  // Proper cleanup
                          return;
                      }
                      fclose(fp);      // Proper cleanup
                  }
              }

      - title: "Dir 4.13c. Synchronization primitives shall be called in appropriate sequence"
        description: |
          Synchronization initialization functions (mtx_init, cnd_init) and destruction functions (mtx_destroy, cnd_destroy) shall be called in proper sequence with matching pairs.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: multi-file
        severity: mandatory
        impact: |
          Improper synchronization primitive sequences can lead to resource leaks, deadlocks, or undefined behavior in concurrent programs. All initialization operations must have corresponding cleanup operations.
        code_examples:
          # C examples
          - non_compliant: |
              void setup_synchronization(void) {
                  mtx_t mutex;
                  mtx_init(&mutex, mtx_plain);
                  if (some_condition) {
                      return;  // Mutex not destroyed on this path
                  }
                  mtx_destroy(&mutex);
              }

          - compliant: |
              void setup_synchronization(void) {
                  mtx_t mutex;
                  if (mtx_init(&mutex, mtx_plain) == thrd_success) {
                      if (some_condition) {
                          mtx_destroy(&mutex);  // Proper cleanup
                          return;
                      }
                      mtx_destroy(&mutex);      // Proper cleanup
                  }
              }

      - title: "Dir 4.14. The validity of values received from external sources shall be checked"
        description: |
          Values from external sources (files, user input, network, environment variables) must be validated before use. This includes bounds checking, null termination, and range validation.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Unvalidated external data can cause buffer overruns, injection attacks, infinite loops, division by zero, or other security and safety vulnerabilities.
        code_examples:
          # C examples
          - non_compliant: |
              void process_input(void) {
                  char input[128];
                  scanf("%128c", input);       // Not null-terminated
                  printf("%s", input);         // Potential buffer overrun
              }

          - compliant: |
              void process_input(void) {
                  char input[128];
                  if (scanf("%127s", input) == 1) {  // Ensures null termination
                      input[127] = '\0';              // Guarantee termination
                      printf("%s", input);            // Safe to print
                  }
              }

      - title: "Dir 4.15. Evaluation of floating-point expressions shall not lead to the undetected generation of infinities and NaNs"
        description: |
          Floating-point arithmetic that can generate infinities or NaNs must be adequately tested. Results must be checked before being passed to code sections not designed to handle special values.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Undetected infinities and NaNs can cause unpredictable behavior, incorrect calculations, and system failures. These special values have unique properties that can break normal program logic and propagate errors.
        code_examples:
          # C examples
          - non_compliant: |
              #include <math.h>
              void process_data(double x) {
                  double result = sqrt(x);     // Could generate NaN for negative x
                  double ratio = 1.0 / result; // Could generate infinity
                  use_value(ratio);            // Not tested for special values
              }

          - compliant: |
              #include <math.h>
              void process_data(double x) {
                  if (x >= 0.0) {              // Prevent NaN generation
                      double result = sqrt(x);
                      if (isfinite(result) && result != 0.0) {  // Check for special values
                          double ratio = 1.0 / result;
                          if (isfinite(ratio)) {
                              use_value(ratio);    // Safe to use
                          }
                      }
                  }
              }

  - name: "4.5. Concurrency considerations"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Dir 5.1. There shall be no data races between threads"
        description: |
          Shared objects between threads must be protected by appropriate synchronization mechanisms. Two conflicting actions in different threads where at least one is non-atomic results in undefined behavior.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: multi-file
        severity: mandatory
        impact: |
          Data races cause memory corruption, unexpected values, and erratic behavior that is hard to reproduce. Unsynchronized access can lead to inconsistent reads/writes and system instability.
        code_examples:
          # C examples
          - non_compliant: |
              int32_t shared_counter = 0;
              // Thread 1
              void thread1_func(void) {
                  shared_counter++;  // Unsynchronized write
              }
              // Thread 2
              void thread2_func(void) {
                  shared_counter--;  // Unsynchronized write - data race
              }

          - compliant: |
              #include <threads.h>
              int32_t shared_counter = 0;
              mtx_t counter_mutex;
              // Thread 1
              void thread1_func(void) {
                  mtx_lock(&counter_mutex);
                  shared_counter++;  // Synchronized write
                  mtx_unlock(&counter_mutex);
              }

      - title: "Dir 5.2. There shall be no deadlocks between threads"
        description: |
          Synchronization mechanisms shall not introduce cyclic dependencies between threads.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: multi-file
        severity: mandatory
        impact: |
          Deadlocks cause programs to hang indefinitely, making systems unresponsive. They are particularly dangerous in real-time and safety-critical systems where responsiveness is essential.
        code_examples:
          # C examples
          - non_compliant: |
              mtx_t mutex_A, mutex_B;
              // Thread 1
              void thread1_func(void) {
                  mtx_lock(&mutex_A);
                  mtx_lock(&mutex_B);  // Potential deadlock
                  mtx_unlock(&mutex_B);
                  mtx_unlock(&mutex_A);
              }
              // Thread 2
              void thread2_func(void) {
                  mtx_lock(&mutex_B);
                  mtx_lock(&mutex_A);  // Opposite order - deadlock risk
                  mtx_unlock(&mutex_A);
                  mtx_unlock(&mutex_B);
              }

          - compliant: |
              mtx_t mutex_A, mutex_B;
              // Both threads lock in same order
              void thread1_func(void) {
                  mtx_lock(&mutex_A);  // Consistent ordering
                  mtx_lock(&mutex_B);
                  mtx_unlock(&mutex_B);
                  mtx_unlock(&mutex_A);
              }
              void thread2_func(void) {
                  mtx_lock(&mutex_A);  // Same order prevents deadlock
                  mtx_lock(&mutex_B);
                  mtx_unlock(&mutex_B);
                  mtx_unlock(&mutex_A);
              }

      - title: "Dir 5.3. There shall be no dynamic thread creation"
        description: |
          Thread creation shall only occur in a well-defined program start-up phase. Dynamic thread creation during runtime execution is prohibited.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: multi-file
        severity: mandatory
        impact: |
          Uncertainty about the number of running threads reduces analyzability and is error-prone. Thread creation/destruction overhead is unpredictable and can affect system timing and resource management.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              thrd_t worker_thread;
              void process_request(void) {
                  // Dynamic thread creation during runtime
                  thrd_create(&worker_thread, worker_func, NULL);
                  thrd_join(worker_thread, NULL);
              }

          - compliant: |
              #include <threads.h>
              thrd_t worker_threads[MAX_WORKERS];
              int main(void) {
                  // Thread creation only during startup
                  for (int i = 0; i < MAX_WORKERS; i++) {
                      thrd_create(&worker_threads[i], worker_func, NULL);
                  }
                  // ... rest of program
                  return 0;
              }

  - name: "5.1. A standard C environment"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 1.1a. Variables shall not be redeclared in the same scope"
        description: |
          Variables shall not be redeclared within the same scope.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Variable redeclarations can lead to undefined behavior, compilation errors, and maintenance difficulties in safety-critical systems.
        code_examples:
          # C examples
          - non_compliant: |
              int x;
              int x;  // Redeclaration in same scope
              
              void func() {
                  int y;
                  int y;  // Redeclaration in same function scope
              }

          - compliant: |
              int x;
              int z;  // Different variable name
              
              void func() {
                  int y;
                  int w;  // Different variable name
              }

      - title: "Rule 1.1b. Function return types shall match their return statements"
        description: |
          Function return types shall match the type of values returned by return statements.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Mismatched return types can lead to undefined behavior, type conversion errors, and unexpected program behavior.
        code_examples:
          # C examples
          - non_compliant: |
              void func() {
                  return 5;  // Return value from void function
              }
              
              int get_value() {
                  return;    // Missing return value for int function
              }

          - compliant: |
              int func() {
                  return 5;  // Proper return type matches value
              }
              
              void get_value() {
                  return;    // Void function with void return
              }

      - title: "Rule 1.1c. Code complexity shall be kept within reasonable limits"
        description: |
          Code shall maintain reasonable complexity limits. Block nesting depth shall not exceed 15 levels, and functions shall not exceed 200 lines of code.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Excessive complexity can cause compilation issues on resource-constrained systems, reduce code readability, and make maintenance difficult.
        code_examples:
          # C examples
          - non_compliant: |
              void complex_function() {
                  if (1) { if (1) { if (1) { if (1) { if (1) { if (1) { if (1) { if (1) {
                      if (1) { if (1) { if (1) { if (1) { if (1) { if (1) { if (1) { if (1) {
                          // 16 levels deep - exceeds limit
                      }}}}}}}}}}}}}}}}
              }

          - compliant: |
              void simple_function() {
                  if (condition1) {
                      if (condition2) {
                          // Reasonable nesting depth
                          process_data();
                      }
                  }
              }

      - title: "Rule 1.1d. Non-standard C language extensions shall not be used"
        description: |
          Code shall only use standard C90/C99/C11 features and shall not use compiler-specific language extensions such as GCC extensions, inline assembly, or non-standard keywords like __attribute__, __declspec, or typeof.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using non-standard language extensions reduces code portability across different compilers and can introduce undefined behavior in safety-critical systems.
        code_examples:
          # C examples
          - non_compliant: |
              // Non-standard GCC extensions
              __attribute__((packed)) struct my_struct { int x; };
              typeof(variable) another_var;
              __asm__("nop");  // Inline assembly
              
              // Non-standard keywords
              __declspec(dllexport) void func(void);

          - compliant: |
              // Standard C features only
              struct my_struct { int x; };
              int another_var;  // Explicit type declaration
              
              // Standard function declaration
              void func(void);

      - title: "Rule 1.3. Specific undefined behavior patterns shall be avoided"
        description: |
          Code shall avoid specific patterns known to cause undefined behavior: multiple unsequenced modifications to the same object, array bounds violations, use of uninitialized variables, and null pointer dereferences.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          These specific undefined behavior patterns can cause unpredictable program execution, security vulnerabilities, and non-portable code in safety-critical systems.
        code_examples:
          # C examples
          - non_compliant: |
              int i = 0;
              int result = ++i + ++i;  // Multiple unsequenced modifications
              
              int arr[5];
              arr[10] = 42;  // Array bounds violation
              
              int uninitialized_var;
              int value = uninitialized_var + 1;  // Use of uninitialized variable
              
              int *ptr = NULL;
              *ptr = 5;  // Null pointer dereference

          - compliant: |
              int i = 0;
              ++i;
              int result = i + i;  // Well-defined sequencing
              
              int arr[5];
              arr[4] = 42;  // Within bounds access
              
              int initialized_var = 0;
              int value = initialized_var + 1;  // Use of properly initialized variable
              
              int valid_var = 10;  // Declare variable first
              int *ptr = &valid_var;
              *ptr = 5;  // Valid pointer dereference

      - title: "Rule 1.4. Only standard C environment features shall be used"
        description: |
          Emergent language features introduced in newer C standards shall not be used.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Emergent language features may have instances of undefined, unspecified, or implementation-defined behavior that do not meet developer expectations. Using them without proper analysis can introduce subtle bugs and portability issues.
        code_examples:
          # C examples
          - non_compliant: |
              #define __STDC_WANT_LIB_EXT1__ 1
              #include <stdio.h>
              
              char dest[10];
              gets_s(dest, sizeof(dest));  // Annex K function

          - compliant: |
              #define __STDC_WANT_LIB_EXT1__ 0
              #include <stdio.h>
              
              char dest[10];
              fgets(dest, sizeof(dest), stdin);  // Standard function

      - title: "Rule 1.5. Obsolescent language features shall not be used"
        description: |
          Obsolescent features identified in the Future language directions and Future library directions sections of the C Standard shall not be used.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Obsolescent features are superseded by safer alternatives or exhibit undesirable behavior. They may be withdrawn in future C Standard editions, leading to compilation failures and maintenance issues.
        code_examples:
          # C examples
          - non_compliant: |
              char *gets(char *s);  // Obsolescent function declaration
              
              char buffer[100];
              gets(buffer);  // Using obsolescent gets function

          - compliant: |
              #include <stdio.h>
              
              char buffer[100];
              fgets(buffer, sizeof(buffer), stdin);  // Use safer alternative

  - name: "5.2. Unused code"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 2.1. Project shall not contain unreachable code"
        description: |
          A project shall not contain unreachable code.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Unreachable code wastes memory, may cause longer jump instructions, and can prevent loops from fitting in instruction cache. It may indicate logical errors in the program design.
        code_examples:
          # C examples
          - non_compliant: |
              int func(int x) {
                  if (x > 0) {
                      return 1;
                  } else {
                      return 0;
                  }
                  x = 5;  // Unreachable code after return statements
              }

          - compliant: |
              int func(int x) {
                  if (x > 0) {
                      return 1;
                  } else {
                      return 0;
                  }
                  // No unreachable code
              }

      - title: "Rule 2.2. Project shall not contain dead code"
        description: |
          A project shall not contain dead code. Dead code consists of operations that are executed but whose removal would not affect program behavior.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Dead code may indicate program logic errors and can cause confusion since compilers may remove it. It wastes computational resources and makes code harder to maintain.
        code_examples:
          # C examples
          - non_compliant: |
              void func(void) {
                  int x;
                  x = 42;        // Dead code: x is never read
                  5 + 3;         // Dead code: result not used
                  (int32_t)x;    // Dead code: cast result not used
              }

          - compliant: |
              void func(void) {
                  int x;
                  x = 42;
                  printf("%d", x);   // x is used
                  (void)(5 + 3);     // Explicit void cast shows intent
              }

      - title: "Rule 2.3. Project should not contain unused type declarations"
        description: |
          A project should not contain unused type declarations.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: multi-file
        severity: mandatory
        impact: |
          Unused type declarations can confuse code reviewers and maintainers, making it unclear whether the types are needed or can be safely removed. This reduces code clarity and maintainability.
        code_examples:
          # C examples
          - non_compliant: |
              int16_t func(void) {
                  typedef int16_t local_Type;  // Unused type declaration
                  return 67;
              }

          - compliant: |
              int16_t func(void) {
                  typedef int16_t local_Type;
                  local_Type value = 67;  // Type is actually used
                  return value;
              }

      - title: "Rule 2.4. Project should not contain unused tag declarations"
        description: |
          A project should not contain unused tag declarations.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: multi-file
        severity: mandatory
        impact: |
          Unused tag declarations can confuse code reviewers and maintainers, making it unclear whether the tags are needed or can be safely removed. This reduces code clarity and maintainability.
        code_examples:
          # C examples
          - non_compliant: |
              void func(void) {
                  enum state { S_init, S_run, S_sleep };  // Unused tag
              }
              
              typedef struct record_t {  // Unused tag in typedef
                  uint16_t key;
                  uint16_t val;
              } record1_t;
          
          - compliant: |
              void func(void) {
                  enum state { S_init, S_run, S_sleep };
                  enum state current = S_init;  // Tag is used
              }
              
              typedef struct {  // No unnecessary tag
                  uint16_t key;
                  uint16_t val;
              } record2_t;

      - title: "Rule 2.5. Project should not contain unused macro definitions"
        description: |
          A project should not contain unused macro definitions.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: multi-file
        severity: mandatory
        impact: |
          Unused macro definitions can confuse code reviewers and maintainers, making it unclear whether the macros are needed or can be safely removed. This reduces code clarity and maintainability.
        code_examples:
          # C examples
          - non_compliant: |
              #define SIZE 4
              #define DATA 3  // Unused macro
              
              void use_macro(void) {
                  use_int16(SIZE);
              }

          - compliant: |
              #define SIZE 4
              #define DATA 3
              
              void use_macro(void) {
                  use_int16(SIZE);
                  use_int16(DATA);  // Both macros are used
              }

      - title: "Rule 2.6. Function should not contain unused label declarations"
        description: |
          A function should not contain unused label declarations.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Unused label declarations can confuse code reviewers and maintainers, making it unclear whether the labels are needed or can be safely removed. This reduces code clarity and maintainability.
        code_examples:
          # C examples
          - non_compliant: |
              void unused_label(void) {
                  int16_t x = 6;
              label1:  // Unused label
                  use_int16(x);
              }

          - compliant: |
              void used_label(void) {
                  int16_t x = 6;
                  if (x > 5) goto label1;
                  x = 10;
              label1:  // Label is used
                  use_int16(x);
              }

      - title: "Rule 2.7. Function should not contain unused parameters"
        description: |
          A function should not contain unused parameters.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Unused parameters can indicate implementation-specification mismatches and confuse code reviewers. They may also suggest incomplete or incorrect function implementation.
        code_examples:
          # C examples
          - non_compliant: |
              void withunusedpara(uint16_t *para1, int16_t unusedpara) {
                  *para1 = 42U;  // unusedpara is not used
              }

          - compliant: |
              void withusedpara(uint16_t *para1, int16_t usedpara) {
                  *para1 = 42U + usedpara;  // Both parameters used
              }

      - title: "Rule 2.8. Project should not contain unused object definitions"
        description: |
          A project should not contain unused object definitions. An object is unused if its definition and declarations can be removed without affecting compilation.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: multi-file
        severity: mandatory
        impact: |
          Unused object definitions can confuse code reviewers and maintainers, making it unclear whether the objects are needed or can be safely removed. This reduces code clarity and maintainability.
        code_examples:
          # C examples
          - non_compliant: |
              static int unused_var = 42;  // Unused object definition
              
              void func(void) {
                  int x = 10;
                  // unused_var is never referenced
              }

          - compliant: |
              static int used_var = 42;
              
              void func(void) {
                  int x = 10 + used_var;  // Object is used
              }

  - name: "5.3. Comments"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 3.1. Character sequences /* and // shall not be used within comments"
        description: |
          The character sequences /* and // shall not be used within a comment. These sequences within comments likely indicate missing comment end markers or nested commenting issues.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Comment sequences within comments can cause accidental code removal or unintended commenting of critical safety functions. This can lead to serious safety issues when expected code is not executed.
        code_examples:
          # C examples
          - non_compliant: |
              /* This is a comment /* with nested comment start */
              
              /* This contains // comment sequence inside */
              
              // This comment contains /* block comment start sequence

          - compliant: |
              /* This is a proper comment without nested sequences */
              
              // This is a proper single-line comment
              
              /* URI exception: https://www.example.com/path */

      - title: "Rule 3.2. Line-splicing shall not be used in // comments"
        description: |
          Line-splicing shall not be used in // comments. A backslash at the end of a // comment line causes the next line to become part of the comment.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Line-splicing in // comments can cause unintentional removal of executable code, as the following line becomes part of the comment instead of being executed.
        code_examples:
          # C examples
          - non_compliant: |
              uint16_t x = 0; // comment \
              if (b) {         // This line becomes part of comment
                  ++x;
              }

          - compliant: |
              uint16_t x = 0; // comment without backslash
              if (b) {        // This line is executable code
                  ++x;
              }

  - name: "5.4. Character sets and lexical conventions"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 4.1. Octal and hexadecimal escape sequences shall be terminated"
        description: |
          Octal and hexadecimal escape sequences shall be terminated by either the start of another escape sequence or the end of the character constant or string literal.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Unterminated escape sequences can cause confusion about character interpretation and lead to implementation-defined behavior for multi-character constants, making code non-portable.
        code_examples:
          # C examples
          - non_compliant: |
              const char *s1 = "\x41g";    // Non-compliant: not terminated
              int c1 = '\141t';            // Non-compliant: not terminated

          - compliant: |
              const char *s2 = "\x41" "g"; // Terminated by end of literal
              const char *s3 = "\x41\x67"; // Terminated by another escape
              int c2 = '\141\t';           // Terminated by another escape

      - title: "Rule 4.2. Trigraphs should not be used"
        description: |
          Trigraphs should not be used.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Trigraphs can cause unexpected character interpretation, leading to code that behaves differently than intended. They can be accidentally triggered by innocent-looking question mark sequences.
        code_examples:
          # C examples
          - non_compliant: |
              char *msg = "(Date should be in the form ??-??-??)";
              // Actually interpreted as: "(Date should be in the form ~~]"

          - compliant: |
              char *msg = "(Date should be in the form DD-MM-YY)";
              // Clear and unambiguous format specification

  - name: "5.5. Identifiers"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 5.1. External identifiers shall be distinct"
        description: |
          External identifiers shall be distinct within the limits imposed by the implementation. Different external identifiers must be distinguishable based on significant characters and case sensitivity rules.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Non-distinct external identifiers can cause undefined behavior and linking errors. This is critical for portability across different implementations with varying identifier length limits.
        code_examples:
          # C examples
          - non_compliant: |
              // Implementation supports 31 significant characters
              int32_t engine_exhaust_gas_temperature_raw;
              int32_t engine_exhaust_gas_temperature_scaled;  // Non-compliant: not distinct
              
              // Implementation supports 6 case-insensitive characters
              // file1.c
              int32_t abc = 0;
              // file2.c  
              int32_t ABC = 0;  // Non-compliant: not distinct

          - compliant: |
              // Shortened to be distinct within limits
              int32_t engine_exhaust_gas_temp_raw;
              int32_t engine_exhaust_gas_temp_scaled;  // Compliant: distinct
              
              // Use clearly different names
              int32_t sensor_abc = 0;
              int32_t value_xyz = 0;  // Compliant: distinct

      - title: "Rule 5.2. Identifiers in same scope and namespace shall be distinct"
        description: |
          Identifiers declared in the same scope and name space shall be distinct within implementation limits. This excludes external identifiers and macro identifiers covered by other rules.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Non-distinct identifiers in the same scope cause undefined behavior and can lead to compilation errors or unexpected program behavior, making code non-portable.
        code_examples:
          # C examples
          - non_compliant: |
              // Implementation supports 31 significant characters (positions 1-31 shown below)
              //                1234567890123456789012345678901
              static int32_t engine_exhaust_gas_temperature_raw;
              static int32_t engine_exhaust_gas_temperature_scaled;  // Non-compliant: identical first 31 chars

          - compliant: |
              // Shortened to be distinct within 31-character limit
              //                1234567890123456789012345678901
              static int32_t engine_exhaust_gas_temp_raw;
              static int32_t engine_exhaust_gas_temp_scaled;  // Compliant: distinct within limit

      - title: "Rule 5.3. Inner scope identifier shall not hide outer scope identifier"
        description: |
          An identifier declared in an inner scope shall not hide an identifier declared in an outer scope. Inner identifiers must be distinct from any outer scope identifiers.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Identifier hiding can cause developer confusion about which variable is being referenced, leading to logic errors and maintenance difficulties.
        code_examples:
          # C examples
          - non_compliant: |
              int16_t xyz = 0;  // File scope
              
              void fn1(void) {
                  int16_t i;  // Outer block scope
                  {
                      int16_t i;  // Non-compliant: hides outer i
                      i = 3;
                  }
              }
              
              void fn2(struct astruct xyz) {  // Non-compliant: hides global xyz
                  g(&xyz);
              }

          - compliant: |
              int16_t global_xyz = 0;  // File scope
              
              void fn1(void) {
                  int16_t outer_i;  // Outer block scope
                  {
                      int16_t inner_i;  // Compliant: distinct name
                      inner_i = 3;
                  }
              }
              
              void fn2(struct astruct param_data) {  // Compliant: distinct name
                  g(&param_data);
              }

      - title: "Rule 5.4a. Macro names shall be distinct from other macro names"
        description: |
          Macro names shall be distinct from other macro names within implementation limits.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Non-distinct macro names cause undefined behavior and can lead to preprocessing errors or unexpected macro expansions, making code non-portable.
        code_examples:
          # C examples
          - non_compliant: |
              // Implementation supports 31 significant characters (positions 1-31 shown below)
              //       1234567890123456789012345678901
              #define engine_exhaust_gas_temperature_raw egt_r
              #define engine_exhaust_gas_temperature_scaled egt_s  // Non-compliant: identical first 31 chars

          - compliant: |
              // Shortened to be distinct within 31-character limit
              //       1234567890123456789012345678901
              #define engine_exhaust_gas_temp_raw egt_r
              #define engine_exhaust_gas_temp_scaled egt_s  // Compliant: distinct within limit

      - title: "Rule 5.4b. Macro names shall be distinct from their parameters"
        description: |
          Macro names shall be distinct from their parameter names within implementation limits.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Non-distinct macro names and parameters cause undefined behavior and can lead to preprocessing errors or unexpected macro behavior.
        code_examples:
          # C examples
          - non_compliant: |
              #define MAX(MAX, y) ((MAX) > (y) ? (MAX) : (y))  // Non-compliant: macro name same as parameter

          - compliant: |
              #define MAX(x, y) ((x) > (y) ? (x) : (y))  // Compliant: distinct names

      - title: "Rule 5.4c. Macro parameter names shall be distinct from each other"
        description: |
          Parameter names within a macro shall be distinct from each other within implementation limits.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Duplicate parameter names cause undefined behavior and make it unclear which parameter is being referenced in the macro expansion.
        code_examples:
          # C examples
          - non_compliant: |
              #define MACRO(x, x)  // Non-compliant: duplicate parameter names
              #define ADD(a, b, a) ((a) + (b))  // Non-compliant: parameter 'a' repeated

          - compliant: |
              #define MACRO(x, y)  // Compliant: distinct parameter names
              #define ADD(a, b, c) ((a) + (b) + (c))  // Compliant: all parameters distinct

      - title: "Rule 5.5. Identifiers shall be distinct from macro names"
        description: |
          Identifiers shall be distinct from macro names within implementation limits. Names of macros and identifiers that exist after preprocessing must be distinguishable.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using the same name for macros and identifiers can cause developer confusion and unexpected behavior when the macro is expanded or when identifiers are used.
        code_examples:
          # C examples
          - non_compliant: |
              #define Sum(x, y) ((x) + (y))
              int16_t Sum;  // Non-compliant: identifier same as macro name
              
              #define low_pressure_turbine_temperature_1 lp_tb_temp_1
              static int32_t low_pressure_turbine_temperature_2;  // Non-compliant: not distinct

          - compliant: |
              #define Sum(x, y) ((x) + (y))
              int16_t total;  // Compliant: distinct from macro name
              
              #define low_pressure_turbine_temp_1 lp_tb_temp_1
              static int32_t low_pressure_turbine_temp_2;  // Compliant: distinct

      - title: "Rule 5.6. Typedef name shall be a unique identifier"
        description: |
          A typedef name shall be unique across all name spaces and translation units. Multiple declarations are only permitted when the typedef is in a header file included in multiple sources.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Reusing typedef names can lead to developer confusion and potential type mismatches, making code harder to understand and maintain.
        code_examples:
          # C examples
          - non_compliant: |
              typedef unsigned char u8_t;
              typedef unsigned char u8_t;  // Non-compliant: reused typedef name
              
              typedef float mass;
              typedef double mass;  // Non-compliant: redefining typedef with different type

          - compliant: |
              typedef unsigned char u8_t;
              // Only one declaration of u8_t typedef
              
              typedef float mass;
              void func(void) {
                  mass vehicle_mass = 0.0f;  // Compliant: using typedef properly
                  float weight = 0.0f;       // Compliant: variable names in different namespace
              }

      - title: "Rule 5.7. Tag name shall be a unique identifier"
        description: |
          A tag name shall be unique across all name spaces and translation units. All declarations of the same tag must specify the same type.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Reusing tag names can cause undefined behavior in C90 and constraint violations in C99+, leading to compilation errors and developer confusion.
        code_examples:
          # C examples
          - non_compliant: |
              struct stag { uint16_t a; uint16_t b; };
              union stag { uint16_t a; };  // Non-compliant: different type with same tag
              
              struct deer { uint16_t a; };
              void foo(void) {
                  struct deer { uint32_t a; };  // Non-compliant: tag reused with different type
              }

          - compliant: |
              struct point { uint16_t x; uint16_t y; };
              union value { uint16_t i; float f; };  // Compliant: distinct tag names
              
              typedef struct coord { uint16_t x; uint16_t y; } coord;  // Compliant: exception allowed

      - title: "Rule 5.8. External linkage identifiers shall be unique"
        description: |
          Identifiers that define objects or functions with external linkage shall be unique across all name spaces and translation units.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Non-unique external identifiers can cause linking errors and developer confusion, especially in multi-file projects where the same name might be used for different purposes.
        code_examples:
          # C examples
          - non_compliant: |
              // file1.c
              int32_t count;  // External linkage
              void foo(void) { }  // External linkage
              
              // file2.c
              void foo(void) { }  // Non-compliant: "foo" not unique (external linkage)
              int16_t count;  // Non-compliant: "count" not unique

          - compliant: |
              // file1.c
              int32_t global_count;  // External linkage
              void process_data(void) { }  // External linkage
              
              // file2.c
              static void helper_func(void) { }  // Compliant: distinct name
              int16_t local_index;  // Compliant: distinct name

      - title: "Rule 5.9. Internal linkage identifiers should be unique"
        description: |
          Identifiers that define objects or functions with internal linkage should be unique across all name spaces and translation units, including those with no linkage.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Non-unique internal linkage identifiers can cause developer confusion and make code harder to understand and maintain, even though it doesn't cause compilation errors.
        code_examples:
          # C examples
          - non_compliant: |
              // file1.c
              static int32_t count;  // Internal linkage
              static void foo(void) {
                  int16_t count;  // Non-compliant: clashes with internal linkage identifier
              }
              
              // file2.c  
              static int8_t count;  // Non-compliant: same name as file1.c
              static void foo(void) { }  // Non-compliant: same name as file1.c

          - compliant: |
              // file1.c
              static int32_t file1_count;  // Internal linkage
              static void file1_process(void) {
                  int16_t local_index;  // Compliant: distinct name
              }
              
              // file2.c
              static int8_t file2_count;  // Compliant: distinct name
              static void file2_process(void) { }  // Compliant: distinct name

      - title: "Rule 5.10. Reserved identifiers and macro names shall not be declared"
        description: |
          Reserved identifiers or macro names shall not be declared. This includes identifiers beginning with underscore, file scope identifiers from Section 7 of the C Standard, and macro names from standard headers.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using reserved identifiers can cause undefined behavior as implementations may treat them specially or rely on their standard behavior for optimization and built-in operations.
        code_examples:
          # C examples
          - non_compliant: |
              extern void *memcpy(void *s1, const void *s2, size_t n);  // Non-compliant: reserved identifier
              
              static double _BUILTIN_square(double x) {  // Non-compliant: underscore prefix
                  return x * x;
              }
              
              #define __SPECIAL_MACRO 42  // Non-compliant: double underscore prefix

          - compliant: |
              #include <string.h>  // Compliant: use standard header
              
              static double my_square(double x) {  // Compliant: no underscore prefix
                  return x * x;
              }
              
              #define SPECIAL_MACRO 42  // Compliant: no underscore prefix

  - name: "5.6. Types"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 6.1. Bit-fields shall only be declared with appropriate types"
        description: |
          Bit-fields shall only be declared with appropriate types. For C90: unsigned int or signed int. For C99+: unsigned int, signed int, other explicitly signed/unsigned integer types, or _Bool.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using inappropriate bit-field types can cause undefined or implementation-defined behavior, making code non-portable and potentially causing unexpected results.
        code_examples:
          # C examples
          - non_compliant: |
              struct s {
                  int b1:2;           // Non-compliant: plain int not permitted
                  char b2:2;          // Non-compliant: char not permitted
                  signed long b3:2;   // Non-compliant: long not permitted
                  enum color b4:2;    // Non-compliant: enum not permitted
              };

          - compliant: |
              typedef unsigned int UINT_16;
              struct s {
                  unsigned int b1:2;  // Compliant: unsigned int permitted
                  signed int b2:2;    // Compliant: signed int permitted  
                  UINT_16 b3:2;       // Compliant: typedef for unsigned int
                  _Bool b4:1;         // Compliant: _Bool permitted (C99+)
              };

      - title: "Rule 6.2. Single-bit named bit-fields shall not be of signed type"
        description: |
          Single-bit named bit-fields shall not be of a signed type.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Single-bit signed bit-fields cannot represent useful values since they have only a sign bit and no value bits, leading to confusing and potentially incorrect behavior.
        code_examples:
          # C examples
          - non_compliant: |
              struct flags {
                  signed int flag1:1;    // Non-compliant: single-bit signed
                  int flag2:1;           // Non-compliant: int may be signed
              };

          - compliant: |
              struct flags {
                  unsigned int flag1:1;  // Compliant: single-bit unsigned
                  signed int flag2:2;    // Compliant: multi-bit signed allowed
                  unsigned int :1;       // Compliant: unnamed bit-field allowed
              };

      - title: "Rule 6.3. Bit-field shall not be declared as member of union"
        description: |
          A bit-field shall not be declared as a member of a union.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Bit-fields in unions have implementation-defined positioning, making type-punning unclear and potentially causing incorrect bit access patterns across different compilers.
        code_examples:
          # C examples
          - non_compliant: |
              union U2 {
                  uint32_t small:8;   // Non-compliant: bit-field in union
                  uint32_t big;
              };
              
              union U3 {
                  uint32_t small:8;   // Non-compliant: bit-field in union
                  uint32_t big:24;    // Non-compliant: bit-field in union
              };

          - compliant: |
              union U1 {
                  uint8_t small;      // Compliant: clear overlay behavior
                  uint32_t big;
              };
              
              union U4 {
                  struct {            // Compliant: bit-fields in sub-object
                      uint8_t a:4;
                      uint8_t b:4;
                  } q;
                  uint16_t r;
              };

  - name: "5.7. Literals and constants"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 7.1. Octal constants shall not be used"
        description: |
          Octal constants shall not be used.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using octal constants can lead to unexpected values and calculation errors when developers mistakenly interpret them as decimal numbers, potentially causing logic errors.
        code_examples:
          # C examples
          - non_compliant: |
              extern uint16_t code[10];
              code[1] = 109;  // Decimal 109
              code[2] = 052;  // Non-compliant: octal 052 = decimal 42
              code[3] = 071;  // Non-compliant: octal 071 = decimal 57

          - compliant: |
              extern uint16_t code[10];
              code[1] = 109;  // Compliant: decimal 109
              code[2] = 42;   // Compliant: decimal 42
              code[3] = 57;   // Compliant: decimal 57
              code[4] = 0;    // Compliant: exception for zero

      - title: "Rule 7.2. 'u' or 'U' suffix shall be applied to unsigned integer constants"
        description: |
          A "u" or "U" suffix shall be applied to all integer constants that are represented in an unsigned type.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Without explicit unsigned suffixes, constant types depend on complex factors including magnitude, environment, and base representation, leading to portability issues and unexpected behavior.
        code_examples:
          # C examples
          - non_compliant: |
              // 16-bit int, 32-bit long environment
              uint16_t value1 = 0x8000;   // Non-compliant: unsigned without suffix
              uint32_t value2 = 65536;    // Non-compliant: unsigned without suffix

          - compliant: |
              // Explicit unsigned suffixes
              uint16_t value1 = 0x8000U;  // Compliant: explicit unsigned
              uint32_t value2 = 65536U;   // Compliant: explicit unsigned
              int32_t value3 = 32767;     // Compliant: signed value, no suffix needed

      - title: "Rule 7.3. Lowercase 'l' shall not be used in literal suffix"
        description: |
          The lowercase character "l" shall not be used in a literal suffix.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using lowercase "l" can cause visual confusion with the digit "1", leading to misinterpretation of literal values and potential logic errors.
        code_examples:
          # C examples
          - non_compliant: |
              const int64_t a = 0l;       // Non-compliant: lowercase l
              const uint64_t b = 0lU;     // Non-compliant: lowercase l
              const uint64_t c = 0Ull;    // Non-compliant: lowercase ll
              const long double d = 2.4l; // Non-compliant: lowercase l

          - compliant: |
              const int64_t a = 0L;       // Compliant: uppercase L
              const uint64_t b = 0LU;     // Compliant: uppercase L
              const uint64_t c = 0ULL;    // Compliant: uppercase LL
              const long double d = 2.4L; // Compliant: uppercase L

      - title: "Rule 7.4. String literal shall be assigned only to const-qualified char pointer"
        description: |
          A string literal shall not be assigned to an object unless the object's type is "pointer to const-qualified char".
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Attempting to modify string literals results in undefined behavior and may cause crashes or security vulnerabilities. Some implementations store string literals in read-only memory.
        code_examples:
          # C examples
          - non_compliant: |
              char *s = "string";         // Non-compliant: not const-qualified
              "0123456789"[0] = '*';      // Non-compliant: direct modification
              
              extern void f1(char *s1);
              f1("string");               // Non-compliant: parameter not const

          - compliant: |
              const char *p = "string";   // Compliant: const-qualified
              
              extern void f2(const char *s2);
              f2("string");               // Compliant: const parameter
              
              const char *name(void) {
                  return "MISRA";         // Compliant: const return type
              }

      - title: "Rule 7.5a. Integer constant macro argument shall be unsuffixed literal"
        description: |
          The argument of an integer constant macro shall be an unsuffixed integer literal (decimal, octal or hexadecimal).
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using suffixed constants or expressions in integer constant macros causes undefined behavior and breaks the macro's intended type conversion purpose.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdint.h>
              uint32_t u1 = UINT32_C(10UL);    // Non-compliant: suffixed constant
              uint32_t u2 = UINT32_C(10U);     // Non-compliant: suffixed constant
              uint64_t u3 = UINT64_C(100LL);   // Non-compliant: suffixed constant
              int32_t s1 = INT32_C(2L);        // Non-compliant: suffixed constant

          - compliant: |
              #include <stdint.h>
              uint32_t u1 = UINT32_C(10);      // Compliant: unsuffixed integer
              int32_t s1 = -INT32_C(2);        // Compliant: unary minus outside
              uint16_t u2 = UINT16_C(65535);   // Compliant: unsuffixed hexadecimal

      - title: "Rule 7.5b. Integer constant macro argument shall not exceed type limits"
        description: |
          The argument value of an integer constant macro shall not exceed the limits for the equivalent exact-width type indicated by the macro name.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Exceeding type limits in integer constant macros causes undefined behavior and may result in incorrect values or compilation errors.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdint.h>
              uint16_t u1 = UINT16_C(0x10000); // Non-compliant: exceeds 16-bit limit
              uint8_t u2 = UINT8_C(256);       // Non-compliant: exceeds 8-bit limit
              int16_t s1 = INT16_C(32768);     // Non-compliant: exceeds signed 16-bit

          - compliant: |
              #include <stdint.h>
              uint16_t u1 = UINT16_C(65535);   // Compliant: within 16-bit range
              uint8_t u2 = UINT8_C(255);       // Compliant: within 8-bit range
              int16_t s1 = INT16_C(32767);     // Compliant: within signed 16-bit range

      - title: "Rule 7.6. Small integer minimum-width constant macros shall not be used"
        description: |
          The small integer variants of minimum-width integer constant macros shall not be used. Small integer refers to types with width less than int.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Many implementations of small integer macros expand to plain int rather than the expected small type, causing type conflicts and unexpected behavior in generic code.
        code_examples:
          # C examples
          - non_compliant: |
              uint8_t a = UINT8_C(100);   // Non-compliant: typically expands as signed int
              
              #define M(x) _Generic((x), uint8_t: fu8, default: fi)(x)
              M(UINT8_C(100));            // Non-compliant: selects fi, not fu8

          - compliant: |
              uint8_t a = 100U;           // Compliant: explicit type
              uint16_t b = UINT16_C(100); // Compliant: int-width or larger
              uint32_t c = UINT32_C(100); // Compliant: int-width or larger

  - name: "5.8. Declarations and definitions"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 8.1. Types shall be explicitly specified"
        description: |
          Types shall be explicitly specified in all declarations. The implicit int type shall not be used in object declarations, parameters, members, typedefs, or function return types.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Omitting explicit types can lead to confusion and unexpected behavior when the implicit int type is assumed, potentially causing type mismatches and logic errors.
        code_examples:
          # C examples
          - non_compliant: |
              extern x;                        // Non-compliant: implicit int
              const y;                         // Non-compliant: implicit int
              extern f(void);                  // Non-compliant: implicit int return
              extern void g(char c, const k);  // Non-compliant: implicit int for k
              
              struct str {
                  int16_t x;
                  const y;                     // Non-compliant: implicit int for member
              };

          - compliant: |
              extern int16_t x;                // Compliant: explicit type
              const int16_t y;                 // Compliant: explicit type
              extern int16_t f(void);          // Compliant: explicit return type
              extern void g(char c, const int16_t k);  // Compliant: explicit parameter type
              
              struct str {
                  int16_t x;
                  const int16_t y;             // Compliant: explicit member type
              };

      - title: "Rule 8.2a. Function types shall be in prototype form"
        description: |
          Function types shall be in prototype form. This includes function declarations, definitions, and function pointers. Empty parameter lists must use void.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Non-prototype function declarations prevent type checking of arguments, potentially causing undefined behavior from type mismatches and incorrect argument counts.
        code_examples:
          # C examples
          - non_compliant: |
              static int16_t func3();          // Non-compliant: not in prototype form
              
              // Old-style definition
              static int16_t func3(vec, n)     // Non-compliant: old style
              int16_t *vec;
              int16_t n;
              { return vec[n-1]; }
              
              int16_t (*pf1)();               // Non-compliant: no prototype

          - compliant: |
              static int16_t func4(void);      // Compliant: void for no parameters
              
              // Modern definition
              int16_t func1(int16_t n) {       // Compliant: prototype form
                  return n;
              }
              
              int16_t (*pf1)(void);            // Compliant: prototype form

      - title: "Rule 8.2b. Function parameters shall be explicitly named"
        description: |
          All parameters in function prototypes shall have explicitly specified names. This applies to function declarations, definitions, and function pointers.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Unnamed parameters make function interfaces unclear and prevent checking for consistency between declarations and definitions, potentially causing programming errors.
        code_examples:
          # C examples
          - non_compliant: |
              extern void func2(int16_t);      // Non-compliant: parameter name not specified
              typedef int16_t (*pf2_t)(int16_t); // Non-compliant: unnamed parameter

          - compliant: |
              extern int16_t func1(int16_t n); // Compliant: named parameter
              typedef int16_t (*pf3_t)(int16_t n); // Compliant: named parameter
              
              extern void func_no_params(void); // Compliant: void requires no names

      - title: "Rule 8.3a. All declarations shall use same names"
        description: |
          All declarations of an object or function shall use the same parameter and object names.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Inconsistent naming across declarations can cause confusion, make code harder to maintain, and may indicate interface mismatches that could lead to programming errors.
        code_examples:
          # C examples
          - non_compliant: |
              extern void j(int d);
              extern void j(int e);            // Non-compliant: mismatched parameter names
              
              extern int16_t func(int16_t num, int16_t den);
              int16_t func(int16_t den, int16_t num) {  // Non-compliant: names swapped
                  return num / den;
              }

          - compliant: |
              extern void g(signed int b);
              extern void g(signed int);       // Compliant: unnamed parameter allowed
              
              extern int16_t func(int16_t num, int16_t den);
              int16_t func(int16_t num, int16_t den) {  // Compliant: consistent names
                  return num / den;
              }

      - title: "Rule 8.3b. All declarations shall use same type qualifiers"
        description: |
          All declarations of an object or function shall use the same type qualifiers.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Inconsistent type qualifiers across declarations can cause confusion and may indicate interface mismatches that could lead to undefined behavior.
        code_examples:
          # C examples
          - non_compliant: |
              extern void h(int * const c);
              extern void h(int * c);          // Non-compliant: mismatched qualifiers
              
              extern void k(const int x);
              void k(int x);                   // Non-compliant: mismatched const qualifier

          - compliant: |
              extern void f(signed int a);
              void f(int a);                   // Compliant: compatible basic types
              
              extern void h(int * const c);
              void h(int * const c);           // Compliant: consistent qualifiers

      - title: "Rule 8.4. Compatible declaration shall be visible when external object/function is defined"
        description: |
          A compatible declaration shall be visible when an object or function with external linkage is defined.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Without visible declarations, the compiler cannot verify compatibility between declarations and definitions, potentially causing undefined behavior from type mismatches.
        code_examples:
          # C examples
          - non_compliant: |
              extern uint16_t speed = 6000u;   // Non-compliant: no prior declaration
              uint8_t pressure = 101u;         // Non-compliant: no prior declaration
              
              void func4(void) {               // Non-compliant: no prior declaration
                  // Function definition
              }

          - compliant: |
              extern int16_t count;            // Declaration
              int16_t count = 0;               // Compliant: compatible definition
              
              extern void func1(void);         // Declaration
              void func1(void) {               // Compliant: compatible definition
                  // Function definition
              }

      - title: "Rule 8.5. External object/function shall be declared once in one file only"
        description: |
          An external object or function shall be declared once in one and only one file. Typically this should be in a header file included by all users.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Multiple declarations in different files can lead to inconsistencies and maintenance problems when interfaces change, potentially causing undefined behavior.
        code_examples:
          # C examples
          - non_compliant: |
              // file1.c
              extern int16_t global_var;       // Declaration in source file
              
              // file2.c  
              extern int16_t global_var;       // Non-compliant: duplicate declaration

          - compliant: |
              // shared.h
              extern int16_t global_var;       // Single declaration in header
              
              // file1.c
              #include "shared.h"              // Include header
              
              // file2.c
              #include "shared.h"              // Include same header

      - title: "Rule 8.6. External linkage identifier shall have exactly one external definition"
        description: |
          An identifier with external linkage shall have exactly one external definition.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Multiple definitions cause undefined behavior and linking errors, while missing definitions cause linking failures when the identifier is referenced.
        code_examples:
          # C examples
          - non_compliant: |
              // file1.c
              int16_t i = 10;                  // First definition
              
              // file2.c
              int16_t i = 20;                  // Non-compliant: second definition
              
              // file3.c
              int16_t k;                       // Tentative definition
              // file4.c  
              int16_t k = 0;                   // Non-compliant: becomes second definition

          - compliant: |
              // shared.h
              extern int16_t global_value;     // Declaration
              
              // file1.c
              #include "shared.h"
              int16_t global_value = 10;       // Single definition
              
              // file2.c
              #include "shared.h"              // Uses declaration, no definition

      - title: "Rule 8.7. External linkage should be avoided for single translation unit use"
        description: |
          Functions and objects should not be defined with external linkage if they are referenced in only one translation unit. Use internal linkage instead.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Unnecessary external linkage increases the risk of inadvertent access, name collisions with libraries, and reduces encapsulation benefits.
        code_examples:
          # C examples
          - non_compliant: |
              // file.h
              extern void ext_fn2(void);       // Non-compliant: only used locally
              
              // file1.c
              void ext_fn2(void) {             // Non-compliant: external but local use
                  // Function definition
              }
              void caller(void) {
                  ext_fn2();                   // Only caller in same file
              }

          - compliant: |
              // file1.c  
              static void local_fn(void) {     // Compliant: internal linkage
                  // Function definition
              }
              void caller(void) {
                  local_fn();                  // Local use with internal linkage
              }

      - title: "Rule 8.8. Static storage class shall be used for internal linkage"
        description: |
          The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Inconsistent use of storage class specifiers can cause confusion about linkage and may lead to unexpected linkage behavior based on prior declarations.
        code_examples:
          # C examples
          - non_compliant: |
              static int32_t x = 0;            // Definition: internal linkage
              extern int32_t x;                // Non-compliant: inconsistent linkage
              
              static int32_t f(void);          // Declaration: internal linkage
              int32_t f(void) {                // Non-compliant: missing static
                  return 1;
              }

          - compliant: |
              static int32_t x = 0;            // Definition: internal linkage
              static int32_t x;                // Compliant: consistent static
              
              static int32_t f(void);          // Declaration: internal linkage
              static int32_t f(void) {         // Compliant: consistent static
                  return 1;
              }

      - title: "Rule 8.9. Object should be declared at block scope for single function use"
        description: |
          An object should be declared at block scope if its identifier only appears in a single function.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          File scope objects that are only used in one function create unnecessary visibility and increase the risk of inadvertent access from other functions.
        code_examples:
          # C examples
          - non_compliant: |
              static int32_t loop_counter = 0; // Non-compliant: file scope but single use
              
              void func(void) {
                  for (loop_counter = 0; loop_counter < N; ++loop_counter) {
                      // Only use of loop_counter
                  }
              }

          - compliant: |
              void func(void) {
                  int32_t loop_counter;        // Compliant: block scope
                  for (loop_counter = 0; loop_counter < N; ++loop_counter) {
                      // Local scope usage
                  }
              }
              
              uint32_t count(void) {
                  static uint32_t call_count = 0;  // Compliant: static needed for persistence
                  return ++call_count;
              }

      - title: "Rule 8.10. Inline function shall be declared with static storage class"
        description: |
          An inline function shall be declared with the static storage class.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Inline functions with external linkage but no definition in the same translation unit cause undefined behavior. Timing differences between inline and external definitions can affect real-time programs.
        code_examples:
          # C examples
          - non_compliant: |
              inline int add(int a, int b) {   // Non-compliant: external linkage
                  return a + b;
              }
              
              extern inline int multiply(int a, int b);  // Non-compliant: external linkage

          - compliant: |
              static inline int add(int a, int b) {      // Compliant: static linkage
                  return a + b;
              }
              
              // In header file for multi-unit availability
              static inline int multiply(int a, int b) { // Compliant: static inline
                  return a * b;
              }

      - title: "Rule 8.11. External array size should be explicitly specified"
        description: |
          When an array with external linkage is declared, its size should be explicitly specified. This applies to non-defining declarations only.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Without explicit size information, consistency checking is harder and static analysis tools cannot perform effective bounds checking across translation units.
        code_examples:
          # C examples
          - non_compliant: |
              extern int32_t array1[];         // Non-compliant: size not specified
              extern char buffer[];            // Non-compliant: incomplete type

          - compliant: |
              extern int32_t array1[10];       // Compliant: explicit size
              extern char buffer[256];         // Compliant: explicit size
              
              // Definition can use implicit sizing
              int32_t local_array[] = {1, 2, 3, 4, 5};  // Compliant: implicit OK for definition

      - title: "Rule 8.12. Implicitly-specified enumeration constants shall be unique"
        description: |
          Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique. Any value replication must be made explicit.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Implicit value duplication in enumerations may be unintentional and can cause unexpected behavior when enum values are compared or used in switch statements.
        code_examples:
          # C examples
          - non_compliant: |
              enum colour {
                  red = 3,
                  blue,                        // blue = 4
                  green,                       // green = 5  
                  yellow = 5                   // Non-compliant: yellow duplicates green implicitly
              };

          - compliant: |
              enum colour {
                  red = 3,
                  blue,                        // blue = 4
                  green = 5,                   // Compliant: explicit value
                  yellow = 5                   // Compliant: explicit duplication
              };
              
              enum status {
                  idle = 0,
                  running,                     // running = 1
                  stopped                      // stopped = 2, all unique
              };

      - title: "Rule 8.13. Pointer should point to const-qualified type when possible"
        description: |
          A pointer should point to a const-qualified type whenever possible, unless it is used to modify an object or copied to a non-const pointer.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Using const-qualified pointers prevents inadvertent modification of objects and makes code intentions clearer, reducing the risk of unintended side effects.
        code_examples:
          # C examples
          - non_compliant: |
              uint16_t read_value(uint16_t *p) {       // Non-compliant: not const
                  return *p;                           // Only reading, not modifying
              }
              
              char last_char(char * const s) {         // Non-compliant: pointer const but not pointee
                  return s[strlen(s) - 1u];
              }
              
              uint16_t first(uint16_t a[5]) {          // Non-compliant: array elements not const
                  return a[0];
              }

          - compliant: |
              uint16_t read_value(const uint16_t *p) { // Compliant: const-qualified
                  return *p;
              }
              
              char last_char(const char * const s) {   // Compliant: both pointer and pointee const
                  return s[strlen(s) - 1u];
              }
              
              uint16_t first(const uint16_t a[5]) {    // Compliant: const array elements
                  return a[0];
              }

      - title: "Rule 8.14. Restrict type qualifier shall not be used"
        description: |
          The restrict type qualifier shall not be used.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Incorrect use of restrict can cause undefined behavior when memory areas overlap unexpectedly, leading to optimization-related bugs that are difficult to debug.
        code_examples:
          # C examples
          - non_compliant: |
              void user_copy(void * restrict p, void * restrict q, size_t n) {
                  // Non-compliant: user-defined function with restrict
                  memcpy(p, q, n);
              }
              
              int process_arrays(int * restrict arr1, int * restrict arr2) {
                  // Non-compliant: restrict in user code
                  return arr1[0] + arr2[0];
              }

          - compliant: |
              void user_copy(void *p, void *q, size_t n) {
                  // Compliant: no restrict qualifier
                  memcpy(p, q, n);  // Standard library can use restrict
              }
              
              int process_arrays(int *arr1, int *arr2) {
                  // Compliant: no restrict qualifier
                  return arr1[0] + arr2[0];
              }

      - title: "Rule 8.15. Explicit alignment specifications shall be consistent"
        description: |
          All declarations of an object with an explicit alignment specification shall specify the same alignment.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Conflicting alignment specifications for objects with external linkage cause undefined behavior, and inconsistent specifications can lead to maintenance errors.
        code_examples:
          # C examples
          - non_compliant: |
              // header.h
              extern alignas(16) int32_t data;
              
              // file1.c
              alignas(8) int32_t data;         // Non-compliant: different alignment
              
              // file2.c  
              extern alignas(16) int32_t other;
              // file3.c
              extern int32_t other;            // Non-compliant: missing alignment spec

          - compliant: |
              // header.h
              extern alignas(16) int32_t data;
              extern int32_t normal_data;      // No alignment needed
              
              // file1.c
              alignas(16) int32_t data;        // Compliant: same alignment
              
              // file2.c
              int32_t normal_data;             // Compliant: consistently no alignment

      - title: "Rule 8.16. Zero alignment specification should not appear"
        description: |
          The alignment specification of zero should not appear in an object declaration. Important alignments should be specified explicitly with non-zero values.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Zero alignment specifications provide no useful information and may indicate configuration or platform-dependent code that should be abstracted by the preprocessor.
        code_examples:
          # C examples
          - non_compliant: |
              alignas(0) int32_t data;         // Non-compliant: zero alignment
              
              // Non-compliant on platforms where sizeof(int) == sizeof(long)
              alignas(sizeof(long) - sizeof(int)) int32_t value;

          - compliant: |
              int32_t normal_data;             // Compliant: no alignment specification
              alignas(16) int32_t aligned_data; // Compliant: explicit non-zero alignment
              
              // Use preprocessor for conditional alignment
              #if REQUIRED_ALIGNMENT > 0
              #define ALIGNED alignas(REQUIRED_ALIGNMENT)
              #else
              #define ALIGNED
              #endif
              ALIGNED int32_t conditional_data;

      - title: "Rule 8.17. At most one explicit alignment specifier should appear"
        description: |
          At most one explicit alignment specifier should appear in an object declaration.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Multiple alignment specifiers can make code harder to understand and maintain, potentially leading to confusion about the actual alignment requirements.
        code_examples:
          # C examples
          - non_compliant: |
              alignas(16) alignas(8) int32_t data;  // Non-compliant: two specifiers
              alignas(16) alignas(0) int32_t value; // Non-compliant: multiple + zero

          - compliant: |
              int32_t normal_data;              // Compliant: no alignment specifier
              alignas(16) int32_t aligned_data; // Compliant: one alignment specifier
              
              // Combine requirements explicitly
              #define SML_ALIGN 16
              #define BIG_ALIGN 32
              alignas(MAX(SML_ALIGN, BIG_ALIGN)) int32_t conditional; // Compliant

      - title: "Rule 8.18. No tentative definitions in header files"
        description: |
          There shall be no tentative definitions in a header file.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Tentative definitions in headers cause multiple object instances to be created, leading to undefined behavior and potential linking errors.
        code_examples:
          # C examples
          - non_compliant: |
              // module.h
              int32_t global_var;              // Non-compliant: tentative definition in header
              static int32_t file_var;         // Non-compliant: definition in header

          - compliant: |
              // module.h
              extern int32_t global_var;       // Compliant: external declaration
              
              // module.c
              #include "module.h"
              int32_t global_var = 0;          // Compliant: definition in source file

      - title: "Rule 8.19. No external declarations in source files"
        description: |
          There should be no external declarations in a source file. External declarations should appear only in header files.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          External declarations in source files break modularity and encapsulation, making interfaces less clear and harder to maintain across the codebase.
        code_examples:
          # C examples
          - non_compliant: |
              // module.c
              extern int32_t global_var;       // Non-compliant: external declaration in source
              
              void function(void) {
                  extern bool flag;            // Non-compliant: block scope external
                  extern void worker(bool);    // Non-compliant: block scope external
                  worker(flag);
              }

          - compliant: |
              // shared.h
              extern int32_t global_var;       // Compliant: in header file
              extern bool flag;
              extern void worker(bool);
              
              // module.c
              #include "shared.h"              // Compliant: use header file
              void function(void) {
                  worker(flag);                // Compliant: declared in header
              }

  - name: "5.9. Initialization"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 9.1. Automatic storage object shall not be read before set"
        description: |
          The value of an object with automatic storage duration shall not be read before it has been set. This includes array elements and structure members as discrete objects.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Reading uninitialized automatic objects leads to undefined behavior as these objects can contain indeterminate values, potentially causing unpredictable program behavior.
        code_examples:
          # C examples
          - non_compliant: |
              void function(bool_t condition) {
                  uint16_t uninitialized;
                  if (condition) {
                      uninitialized = 42;
                  }
                  // Non-compliant: may read uninitialized value
                  if (uninitialized == 42) {
                      process();
                  }
              }
              
              void jump_example(void) {
                  goto label;
                  uint16_t x = 10u;           // Initialization bypassed
              label:
                  x = x + 1u;                 // Non-compliant: x not initialized
              }

          - compliant: |
              void function(bool_t condition) {
                  uint16_t initialized = 0;   // Compliant: explicitly initialized
                  if (condition) {
                      initialized = 42;
                  }
                  if (initialized == 42) {    // Compliant: always initialized
                      process();
                  }
              }
              
              void proper_example(void) {
                  uint16_t x = 10u;           // Initialize before any jumps
                  if (condition) goto label;
                  x = 20u;
              label:
                  x = x + 1u;                 // Compliant: x is initialized
              }

      - title: "Rule 9.2. Aggregate/union initializer shall be enclosed in braces"
        description: |
          The initializer for an aggregate or union shall be enclosed in braces. This applies to both objects and subobjects.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using braces for aggregate initialization improves code clarity and forces consideration of initialization for complex data structures, reducing initialization errors.
        code_examples:
          # C examples
          - non_compliant: |
              int16_t matrix[3][2] = { 1, 2, 0, 0, 5, 6 };  // Non-compliant: no nested braces
              
              int16_t mixed[2][2] = { { 0 }, [1][0] = 0, 1 }; // Non-compliant: mixed style

          - compliant: |
              int16_t matrix[3][2] = { { 1, 2 }, { 0, 0 }, { 5, 6 } }; // Compliant: nested braces
              
              float zeros[3][2] = { 0 };      // Compliant: { 0 } exception
              float explicit[3][2] = { { 0.0f, 0.0f }, { 0.0f, 0.0f }, { 0.0f, 0.0f } }; // Compliant
              
              char text[] = "hello";          // Compliant: string literal exception
              
              struct data {
                  uint16_t len;
                  char buf[8];
              } record = { 5u, { 'a', 'b', 'c', 'd', 'e', '\0', '\0', '\0' } }; // Compliant

      - title: "Rule 9.3. Arrays shall not be partially initialized"
        description: |
          If any element of an array object or subobject is explicitly initialized, then the entire object or subobject shall be explicitly initialized. Exception: Arrays using only designated initializers for sparse initialization are permitted.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Providing explicit initialization for each element makes it clear that every element has been considered, preventing unintended implicit zero-initialization of remaining elements.
        code_examples:
          # C examples
          - non_compliant: |
              int32_t y[3] = { 0, 1 };        // Non-compliant: y[2] is implicitly initialized
              
              float t[4] = { [1] = 1.0f, 2.0f }; // Non-compliant: t[0] and t[3] are implicitly initialized

          - compliant: |
              int32_t x[3] = { 0, 1, 2 };     // Compliant: all elements explicitly initialized
              
              float z[50] = { [1] = 1.0f, [25] = 2.0f }; // Compliant: designated initializers for sparse matrix
              
              float array[5] = { 0 };         // Compliant: {0} exception
              
              char h[10] = "Hello";           // Compliant: string literal exception

      - title: "Rule 9.4. An element of an object shall not be initialized more than once"
        description: |
          An aggregate initializer shall not contain two designators that refer to the same sub-object, nor allow implicit initialization of previously initialized elements.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Multiple initialization can cause confusion and unspecified behavior regarding side effects in initializing expressions, making code unpredictable and harder to maintain.
        code_examples:
          # C examples
          - non_compliant: |
              int16_t a3[5] = { [0] = -5, [1] = -4, [2] = -3, [2] = -2, [4] = -1 }; // Non-compliant: a3[2] initialized twice
              
              struct mystruct { int32_t a; int32_t b; int32_t c; int32_t d; };
              struct mystruct s3 = { .a = 100, .b = -1, .a = 42, .d = 999 }; // Non-compliant: .a initialized twice
              
              struct mystruct s4 = { .b = 2, .c = 3, .a = 1, 4 }; // Non-compliant: b overwritten by positional

          - compliant: |
              int16_t a1[5] = { -5, -4, -3, -2, -1 }; // Compliant: positional initialization
              
              int16_t a2[5] = { [0] = -5, [1] = -4, [2] = -3, [3] = -2, [4] = -1 }; // Compliant: designated without repetition
              
              struct mystruct s1 = { 100, -1, 42, 999 }; // Compliant: positional
              
              struct mystruct s2 = { .a = 100, .b = -1, .c = 42, .d = 999 }; // Compliant: designated without repetition

      - title: "Rule 9.5. Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly"
        description: |
          When using designated initializers for arrays, the array size shall be declared explicitly rather than determined implicitly by the highest index.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Explicit array size declaration makes intent clear and provides protection against constraint violations when indices are changed during development.
        code_examples:
          # C examples
          - non_compliant: |
              int32_t a1[] = { [0] = 1 };     // Non-compliant: size determined implicitly

          - compliant: |
              int32_t a2[10] = { [0] = 1 };   // Compliant: explicit size specification

      - title: "Rule 9.6. An initializer using chained designators shall not contain initializers without designators"
        description: |
          If an aggregate initializer uses chained designators, every initializer in the entire containing initializer list shall specify an element explicitly using a designator.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Mixing chained designators with positional initialization creates confusion about which sub-object is being initialized, making code extremely unclear to readers.
        code_examples:
          # C examples
          - non_compliant: |
              struct S { int32_t x; int32_t y; };
              struct T { int32_t w; struct S s; int32_t z; };
              
              struct T tt = {
                  1,
                  .s.x = 2,   // Non-compliant: chained designator mixed with positional
                  3,
              };

          - compliant: |
              struct S { int32_t x; int32_t y; };
              struct T { int32_t w; struct S s; int32_t z; };
              
              struct T tt_compliant = {
                  .w = 1,
                  .s.x = 2,
                  .s.y = 0,
                  .z = 3,
              };
              
              struct S ab[2] = {
                  [0].x = 1,
                  [1] = { 2, 3 },     // Compliant: braced sub-object exception
              };

      - title: "Rule 9.7. Atomic objects shall be appropriately initialized before being accessed"
        description: |
          Atomic objects shall be initialized before access using assignment operator or atomic_init() for non-static duration, or rely on default initialization for static duration.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Improper atomic initialization can cause data races and undefined behavior, as concurrent access during initialization constitutes a data race even with atomic operations.
        code_examples:
          # C examples
          - non_compliant: |
              void main(void) {
                  _Atomic int32_t ai2;
                  ai2 = 777;          // Non-compliant: not initialized by atomic_init
                  
                  _Atomic int32_t ai4;
                  thrd_create(&id1, t1, &ai4);
                  atomic_init(&ai4, 666); // Non-compliant: initialized after thread creation
              }

          - compliant: |
              _Atomic int32_t g_ai1;  // Compliant: default initialization for static
              
              void main(void) {
                  _Atomic int32_t ai1 = 22;   // Compliant: directly initialized
                  
                  _Atomic int32_t ai3;
                  atomic_init(&ai3, 333);     // Compliant: initialized by atomic_init before access
              }

  - name: "5.10. The essential type model"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 10.1a. Floating and complex types shall not be used with bitwise and shift operators"
        description: |
          Floating and complex floating types are prohibited as operands to bitwise and shift operators as these operations have no meaningful representation for floating-point values.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using floating types with bitwise operators results in constraint violations and undefined behavior, as these operations are not defined for floating-point representations.
        code_examples:
          # C examples
          - non_compliant: |
              float f32a = 1.5f;
              _Complex float cf32a;
              
              f32a & 2U;              // Non-compliant: floating type in bitwise operation
              f32a << 2;              // Non-compliant: floating type in shift operation
              cf32a | 0xFF;           // Non-compliant: complex type in bitwise operation

          - compliant: |
              uint32_t u32a = 2;
              int32_t s32a = 1;
              
              u32a & 2U;              // Compliant: unsigned bitwise operation
              s32a << 2;              // Compliant: signed shift operation
              u32a | 0xFF;            // Compliant: unsigned bitwise operation

      - title: "Rule 10.1b. Non-Boolean expressions shall not be used in Boolean contexts"
        description: |
          Boolean contexts such as conditional expressions and logical operators require operands of essentially Boolean type.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using non-Boolean types in Boolean contexts can lead to confusion about intended logic and may not follow the essential type model's requirement for explicit Boolean usage.
        code_examples:
          # C examples
          - non_compliant: |
              char cha = 'A';
              enum enuma { a1, a2 } ena = a1;
              int8_t s8a = 5;
              uint8_t u8a = 3;
              float f32a = 1.0f;
              
              cha && true;            // Non-compliant: char type used as Boolean value
              ena ? a1 : a2;          // Non-compliant: enum type used as Boolean value
              s8a && true;            // Non-compliant: signed type used as Boolean value
              u8a ? a1 : a2;          // Non-compliant: unsigned type used as Boolean value
              f32a && true;           // Non-compliant: floating type used as Boolean value

          - compliant: |
              bool bla = true, blb = false;
              uint8_t u8a, u8b;
              
              bla && blb;             // Compliant: Boolean operands for logical operation
              bla ? u8a : u8b;        // Compliant: Boolean condition

      - title: "Rule 10.1c. Boolean expressions shall not be used in numeric contexts"
        description: |
          Boolean type expressions shall not be used as operands where numeric values are expected, such as arithmetic and comparison operations.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using Boolean values as numeric operands defeats the purpose of strong typing and can lead to unintended numeric computations with Boolean logic values.
        code_examples:
          # C examples
          - non_compliant: |
              bool bla = true, blb = false;
              
              bla * blb;              // Non-compliant: Boolean used as numeric value
              bla > blb;              // Non-compliant: Boolean used in numeric comparison
              bla + 5;                // Non-compliant: Boolean in arithmetic operation

          - compliant: |
              bool bla = true, blb = false;
              uint8_t u8a = 5, u8b = 3;
              
              bla && blb;             // Compliant: Boolean logical operation
              u8a * u8b;              // Compliant: numeric multiplication
              u8a > u8b;              // Compliant: numeric comparison

      - title: "Rule 10.1d. Character expressions shall not be used in numeric bitwise contexts"
        description: |
          Character type expressions shall not be used as operands to bitwise and shift operators where they would be interpreted as numeric values.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using character types in bitwise operations treats character data as numeric values, which may produce implementation-defined results since character representations vary.
        code_examples:
          # C examples
          - non_compliant: |
              char cha = 'A', chb = 'B';
              
              cha & chb;              // Non-compliant: char type used as numeric value
              cha << 1;               // Non-compliant: char type in shift operation
              cha | 0x20;             // Non-compliant: char in bitwise operation

          - compliant: |
              char cha = 'A', chb = 'B';
              uint8_t u8a = 0x41, u8b = 0x42;
              
              cha > chb;              // Compliant: character comparison allowed
              u8a & u8b;              // Compliant: unsigned bitwise operation
              u8a << 1;               // Compliant: unsigned shift operation

      - title: "Rule 10.1e. Enum expressions shall not be used in arithmetic operations"
        description: |
          Enumeration type expressions shall not be used as operands to arithmetic operators.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using enum types in arithmetic operations may yield results with unexpected types since the underlying integer type is implementation-defined.
        code_examples:
          # C examples
          - non_compliant: |
              enum enuma { a1, a2, a3 } ena = a1;
              
              ena--;                  // Non-compliant: enum type in arithmetic operation
              ena * a1;               // Non-compliant: enum arithmetic operation
              ena + 5;                // Non-compliant: enum in arithmetic

          - compliant: |
              enum enuma { a1, a2, a3 } ena = a1;
              enum { K1 = 1 };        // Anonymous enum constants are signed
              int8_t s8a = 2;
              
              ena > a1;               // Compliant: enum comparison
              K1 * s8a;               // Compliant: anonymous enum constant (signed type)

      - title: "Rule 10.1f. Bitwise operators shall only be applied to unsigned integer operands"
        description: |
          Bitwise operations should only be performed on operands of essentially unsigned type.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Bitwise operations on signed types may produce undefined behavior (for shift operations) or implementation-defined results, making code non-portable.
        code_examples:
          # C examples
          - non_compliant: |
              int8_t s8a = 5, s8b = 3;
              int32_t s32a = 50;
              
              s8a & 2;                // Non-compliant: bitwise operation on signed type
              s32a << 3U;             // Non-compliant: shift operation on signed type
              s8a | s8b;              // Non-compliant: bitwise OR on signed types

          - compliant: |
              uint8_t u8a = 5, u8b = 3;
              uint32_t u32a = 50;
              
              u8a & 2U;               // Compliant: unsigned bitwise operation
              u32a << 3U;             // Compliant: unsigned shift operation
              u8a | u8b;              // Compliant: unsigned bitwise OR

      - title: "Rule 10.1g. Shift operator right operand shall be of unsigned type"
        description: |
          The right-hand operand of shift operators shall be of essentially unsigned type.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using signed types as shift amounts can result in undefined behavior when the value is negative, making program behavior unpredictable.
        code_examples:
          # C examples
          - non_compliant: |
              uint8_t u8a = 10;
              int8_t s8a = 2;
              int32_t shift_amt = -1;
              
              u8a << s8a;             // Non-compliant: shift magnitude uses signed type
              u8a << shift_amt;       // Non-compliant: negative shift amount

          - compliant: |
              uint8_t u8a = 10;
              uint8_t u8_shift = 2;
              
              u8a << u8_shift;        // Compliant: unsigned shift amount
              u8a << 1;               // Compliant: non-negative signed constant exception

      - title: "Rule 10.1h. Unary minus operator shall not be applied to unsigned operands"
        description: |
          The unary minus operator shall not be used with operands of essentially unsigned type.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Applying unary minus to unsigned types can produce implementation-defined results where the signedness depends on the size of int on the target platform.
        code_examples:
          # C examples
          - non_compliant: |
              uint8_t u8a = 5;
              uint16_t u16a = 100;
              
              -u8a;                   // Non-compliant: unary minus on unsigned type
              -u16a;                  // Non-compliant: unary minus on unsigned type

          - compliant: |
              int8_t s8a = 5;
              int16_t s16a = 100;
              uint8_t u8a = 5;
              
              -s8a;                   // Compliant: unary minus on signed type
              -s16a;                  // Compliant: unary minus on signed type
              -(int8_t)u8a;           // Compliant: cast to signed before unary minus

      - title: "Rule 10.1i. Floating-point expressions shall not be tested for equality"
        description: |
          Floating-point expressions shall not be compared for equality or inequality, except when comparing with the literal constants zero, INFINITY, or -INFINITY.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Floating-point equality comparisons between variables often fail unexpectedly due to precision limitations and may vary between implementations, making code unreliable. Comparisons with literal constants zero, INFINITY, and -INFINITY are allowed as they provide deterministic results.
        code_examples:
          # C examples
          - non_compliant: |
              float f32w = -1.0f, f32x = 0.2f, f32y = 0.9f, f32z = 0.5f;
              
              if ((f32w + f32x) == f32y) {}   // Non-compliant: equality comparison between floating-point expressions
              if (f32w != f32y) {}            // Non-compliant: inequality comparison between floating-point variables
              if (f32w == f32z) {}            // Non-compliant: comparing floating-point variables

          - compliant: |
              float f32w = -1.0f, f32y = 0.9f;
              
              if (f32w <= f32y) {}            // Compliant: relational comparison allowed
              if (f32w != 0.0f) {}            // Compliant: inequality with literal zero (Exception)
              if (f32w == 0.0f) {}            // Compliant: equality with literal zero (Exception)
              if (f32w != INFINITY) {}        // Compliant: comparison with INFINITY literal (Exception)
              if (f32w != -INFINITY) {}       // Compliant: comparison with -INFINITY literal (Exception)

      - title: "Rule 10.2. Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations"
        description: |
          Character type expressions may only be used in addition and subtraction with specific type combinations that preserve character semantics.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Restricting character arithmetic prevents misuse of character data as numeric values while allowing legitimate character manipulations like digit conversion and case changes.
        code_examples:
          # C examples
          - non_compliant: |
              int16_t s16a;
              float f32a;
              char cha;
              enum enuma { a1 } ena;
              
              s16a - 'a';             // Non-compliant: character subtracted from wider integer
              '0' + f32a;             // Non-compliant: character with floating type
              cha + ':';              // Non-compliant: character addition without numeric operand
              cha - ena;              // Non-compliant: character with enum type

          - compliant: |
              uint8_t u8a;
              int8_t s8a;
              char cha;
              
              '0' + u8a;              // Compliant: convert u8a to digit
              s8a + '0';              // Compliant: convert s8a to digit
              cha - '0';              // Compliant: convert cha to ordinal
              '0' - s8a;              // Compliant: convert -s8a to digit

      - title: "Rule 10.3. The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category"
        description: |
          Assignment must not narrow essential types or change essential type categories, except for specific permitted cases involving constants and aggregate initialization.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Preventing implicit conversions reduces risk of value loss, sign changes, and precision loss that can occur with automatic type conversions in C.
        code_examples:
          # C examples
          - non_compliant: |
              uint8_t u8a;
              uint16_t u16a;
              uint32_t u32a;
              int8_t s8a;
              int32_t s32a;
              char cha;
              bool bla;
              float f32a;
              _Complex float cf32a;
              
              u8a = 1.0f;             // Non-compliant: unsigned and floating categories
              bla = 0;                // Non-compliant: boolean and signed categories
              cha = 7;                // Non-compliant: character and signed categories
              u8a = 'a';              // Non-compliant: unsigned and character categories
              u16a = u32a;            // Non-compliant: narrower essential type
              f32a = cf32a;           // Non-compliant: real and complex floating categories

          - compliant: |
              uint8_t u8a, u8b, u8c;
              uint16_t u16a;
              uint32_t u32a;
              int8_t s8a;
              char cha;
              bool bla;
              float f32a;
              _Complex float cf32a;
              enum enuma { A1 } ena;
              
              u8a = 0;                // Compliant: exception for signed constants
              bla = (bool)0;          // Compliant: explicit cast
              bla = true;             // Compliant: true is essentially Boolean
              ena = A1;               // Compliant: same essential type
              u8a = 2;                // Compliant: signed constant exception
              u32a = u16a;            // Compliant: assignment to wider type
              u8a = (uint8_t)s8a;     // Compliant: explicit cast
              cf32a = f32a;           // Compliant: real to complex exception

      - title: "Rule 10.4. Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category"
        description: |
          Binary operators subject to usual arithmetic conversions must have operands of the same essential type category, with exceptions for character manipulation and mixed real/complex operations.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Requiring matching essential type categories prevents unexpected implicit conversions and ensures arithmetic operations behave as intended by the developer.
        code_examples:
          # C examples
          - non_compliant: |
              uint8_t u8a, u8b;
              int8_t s8a;
              enum enuma { A1 } ena;
              enum enumb { B1 } enb;
              
              u8b + 2;                // Non-compliant: unsigned and signed categories
              s8a += u8a;             // Non-compliant: signed and unsigned categories
              enb > A1;               // Non-compliant: different enum types
              ena == enb;             // Non-compliant: different enum types

          - compliant: |
              uint8_t u8a, u8b;
              uint16_t u16b;
              char cha;
              enum enuma { A1 } ena;
              float f32a;
              _Complex float cf32a;
              
              ena > A1;               // Compliant: same essential type category
              u8a + u16b;             // Compliant: both unsigned types
              cha += u8a;             // Compliant: character manipulation exception
              cf32a += f32a;          // Compliant: mixed real/complex exception

      - title: "Rule 10.5. The value of an expression should not be cast to an inappropriate essential type"
        description: |
          Explicit casts should avoid inappropriate conversions between essential type categories that may result in meaningless or undefined behavior.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Inappropriate casts can produce unexpected values, particularly when casting to Boolean or enum types, or between floating and character types where no meaningful mapping exists.
        code_examples:
          # C examples
          - non_compliant: |
              typedef int bool_t;
              enum enuma { A1, A2, A3 } ena;
              uint32_t u32a = 3U;
              float f32a;
              char cha;
              
              (bool_t)u32a;           // Non-compliant: non-0/1 value to Boolean
              (enum enuma)3;          // Non-compliant: value outside enumeration constants
              (int32_t)true;          // Non-compliant: Boolean to other type
              (char)f32a;             // Non-compliant: floating to character
              (float)cha;             // Non-compliant: character to floating

          - compliant: |
              typedef int bool_t;
              enum enuma { A1, A2, A3 } ena;
              int32_t s32a;
              uint32_t u32a;
              char cha;
              enum enumb { B1 } enb;
              
              (bool_t)false;          // Compliant: false is essentially Boolean
              (bool_t)0;              // Compliant: exception for 0/1 constants
              (bool_t)1;              // Compliant: exception for 0/1 constants
              (int32_t)u32a;          // Compliant: compatible numeric types
              (int32_t)ena;           // Compliant: enum to integer
              (char)enb;              // Compliant: enum to character

      - title: "Rule 10.6. The value of a composite expression shall not be assigned to an object with wider essential type"
        description: |
          Composite expressions shall not be assigned to objects with wider essential type.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Allowing wider assignments of composite expressions can lead to different results on different platforms due to varying intermediate computation widths.
        code_examples:
          # C examples
          - non_compliant: |
              uint16_t u16a, u16b;
              uint32_t u32a;
              
              u32a = u16a + u16b;     // Non-compliant: composite expression assigned to wider type
              
              void use_uint32(uint32_t x);
              use_uint32(u16a + u16b); // Non-compliant: implicit conversion of function argument

          - compliant: |
              uint16_t u16a, u16b, u16c;
              uint32_t u32a;
              
              u16c = u16a + u16b;     // Compliant: same essential type
              u32a = (uint32_t)u16a + u16b; // Compliant: cast causes addition in uint32_t

      - title: "Rule 10.7. If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type"
        description: |
          When a composite expression is used with arithmetic operators, the other operand must not have wider essential type.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Restricting implicit conversions ensures arithmetic sequences use consistent types, reducing developer confusion and implementation-dependent behavior.
        code_examples:
          # C examples
          - non_compliant: |
              uint16_t u16a, u16b;
              uint32_t u32a;
              
              u32a * (u16a + u16b);   // Non-compliant: implicit conversion of composite expression
              u32a += (u16a + u16b);  // Non-compliant: implicit conversion in compound assignment

          - compliant: |
              uint16_t u16a, u16b, u16c;
              uint32_t u32a, u32b;
              
              u32a * u16a + u16b;     // Compliant: no composite conversion needed
              (u32a * u16a) + u16b;   // Compliant: no composite conversion needed
              u32a * ((uint32_t)u16a + u16b); // Compliant: both operands same type
              u32a += (u32b + u16b);  // Compliant: no composite conversion

      - title: "Rule 10.8. The value of a composite expression shall not be cast to a different essential type category or a wider essential type"
        description: |
          Composite expressions shall not be cast to different essential type categories or wider essential types.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Casting composite expressions to wider types can produce different results on different architectures due to varying intermediate computation widths.
        code_examples:
          # C examples
          - non_compliant: |
              uint16_t u16a, u16b;
              int32_t s32a, s32b;
              uint32_t u32a, u32b;
              
              (uint32_t)(u16a + u16b); // Non-compliant: cast to wider essential type
              (uint16_t)(s32a + s32b); // Non-compliant: different essential type category

          - compliant: |
              uint16_t u16a, u16b;
              int32_t s32a;
              uint32_t u32a, u32b;
              float f32a;
              _Complex float cf32a;
              
              (uint16_t)(u32a + u32b); // Compliant: cast to narrower type same category
              (uint16_t)s32a;          // Compliant: s32a is not composite
              (_Complex float)f32a;    // Compliant: real to complex exception

  - name: "5.11. Pointer type conversions"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 11.1. Conversions shall not be performed between a pointer to a function and any other type"
        description: |
          Function pointers shall only be converted to/from compatible function pointer types. Conversions to object pointers, incomplete pointers, or other types are prohibited.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Converting function pointers to incompatible types results in undefined behavior when the function is called, potentially causing crashes or unpredictable program behavior.
        code_examples:
          # C examples
          - non_compliant: |
              typedef void (*fp16)(int16_t n);
              typedef void (*fp32)(int32_t n);
              
              fp16 fp1;
              fp32 fp2 = (fp32)fp1;           // Non-compliant: different function pointer types
              fp16 fp3 = (fp16)0x8000;        // Non-compliant: integer to function pointer
              fp16 fp4 = (fp16)1.0e6F;        // Non-compliant: float to function pointer

          - compliant: |
              typedef void (*fp16)(int16_t n);
              typedef fp16 (*pfp16)(void);
              extern void f(int16_t n);
              
              fp16 fp1 = NULL;                // Compliant: null pointer constant
              if (fp1 != NULL) {}             // Compliant: comparison with NULL
              fp16 fp5 = f;                   // Compliant: implicit function conversion
              f(1);                           // Compliant: direct function call
              pfp16 pfp1;
              (void)(*pfp1());                // Compliant: cast function pointer to void

      - title: "Rule 11.2. Conversions shall not be performed between a pointer to an incomplete type and any other type"
        description: |
          Pointers to incomplete types shall not be converted to other types, and other types shall not be converted to pointers to incomplete types.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Converting incomplete type pointers may result in incorrectly aligned pointers or break encapsulation, leading to undefined behavior when dereferencing.
        code_examples:
          # C examples
          - non_compliant: |
              struct s;           // Incomplete type
              struct t;           // Different incomplete type
              struct s *sp;
              struct t *tp;
              int16_t *ip;
              
              ip = (int16_t *)sp;             // Non-compliant: incomplete to object pointer
              sp = (struct s *)1234;          // Non-compliant: integer to incomplete pointer
              tp = (struct t *)sp;            // Non-compliant: different incomplete types

          - compliant: |
              struct s;           // Incomplete type
              struct s *sp;
              struct s *f(void);
              
              sp = NULL;                      // Compliant: null pointer constant
              (void)f();                      // Compliant: cast incomplete pointer to void

      - title: "Rule 11.3. A conversion shall not be performed between a pointer to object type and a pointer to a different object type"
        description: |
          Object pointers shall not be converted to pointers of different object types, except for conversions to char pointer types.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Converting between incompatible object pointer types may result in misaligned access or violate strict aliasing rules, causing undefined behavior.
        code_examples:
          # C examples
          - non_compliant: |
              uint8_t *p1;
              uint32_t *p2;
              uint32_t u;
              uint16_t *hi_p;
              int * const *pcpi;
              const int * const *pcpci;
              
              p2 = (uint32_t *)p1;            // Non-compliant: incompatible object types
              hi_p = (uint16_t *)&u;          // Non-compliant: different object types
              pcpci = (const int * const *)pcpi; // Non-compliant: different unqualified types

          - compliant: |
              const short *p;
              const volatile short *q;
              uint32_t *p2;
              char *cp;
              
              q = (const volatile short *)p;  // Compliant: same unqualified type
              cp = (char *)p2;                // Compliant: conversion to char pointer

      - title: "Rule 11.4. A conversion shall not be performed between a pointer to object and an arithmetic type"
        description: |
          Object pointers shall not be converted to/from arithmetic types, except for null pointer constants and specific intptr_t/uintptr_t conversions.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Converting between pointers and arithmetic types may result in misaligned pointers or unrepresentable values, leading to undefined behavior.
        code_examples:
          # C examples
          - non_compliant: |
              uint8_t *p, *q;
              int32_t addr;
              bool b;
              enum etag { A, B } e;
              int16_t *ptr;
              float f;
              
              uint8_t *PORTA = (uint8_t *)0x0002; // Non-compliant: integer to pointer
              addr = (int32_t)&p;             // Non-compliant: pointer to integer
              q = (uint8_t *)addr;            // Non-compliant: integer to pointer
              b = (bool)p;                    // Non-compliant: pointer to Boolean
              e = (enum etag)p;               // Non-compliant: pointer to enum
              f = (float)ptr;                 // Non-compliant: pointer to floating
              ptr = (int16_t *)f;             // Non-compliant: floating to pointer

          - compliant: |
              int16_t *ptr;
              uintptr_t uip1, uip2;
              
              ptr = NULL;                     // Compliant: null pointer constant
              uip1 = (uintptr_t)ptr;          // Conditionally compliant: if representations match
              uip2 = (uintptr_t)(void *)ptr;  // Compliant: via void pointer conversion

      - title: "Rule 11.5. A conversion should not be performed from pointer to void into pointer to object"
        description: |
          Void pointers should not be converted to object pointers except for null pointer constants and immediate conversions from standard memory allocation functions.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Converting void pointers to object pointers may result in incorrectly aligned pointers, leading to undefined behavior when accessing the pointed-to object.
        code_examples:
          # C examples
          - non_compliant: |
              uint32_t *p32;
              uint16_t *p16;
              void *p;
              
              p16 = p;                        // Non-compliant: void to object pointer
              p32 = (uint32_t *)p;            // Non-compliant: void to object pointer
              
              void *p_alloc = malloc(sizeof(int));
              int *ip = p_alloc;              // Non-compliant: conversion not immediate

          - compliant: |
              uint32_t *p32;
              uint16_t *p16;
              void *p;

              p = p32;                        // Compliant: object to void pointer
              p = (void *)p16;                // Compliant: object to void pointer
              p16 = NULL;                     // Compliant: null pointer constant exception
              int *x = malloc(sizeof(int));   // Compliant: immediate conversion from malloc

      - title: "Rule 11.6. A cast shall not be performed between pointer to void and an arithmetic type"
        description: |
          Void pointers shall not be cast to/from arithmetic types, except for null pointer constants and conversions with intptr_t/uintptr_t.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Converting between void pointers and arithmetic types can result in implementation-defined or undefined behavior, making code non-portable.
        code_examples:
          # C examples
          - non_compliant: |
              void *p;
              uint32_t u;
              
              p = (void *)0x1234u;            // Non-compliant: implementation-defined
              p = (void *)1024.0f;            // Non-compliant: undefined behavior
              u = (uint32_t)p;                // Non-compliant: implementation-defined

          - compliant: |
              void *p, *ptr;
              uintptr_t uip;
              
              p = (void *)0;                  // Compliant: null pointer constant exception
              uip = (uintptr_t)ptr;           // Compliant: intptr_t/uintptr_t exception
              p = (void *)uip;                // Compliant: intptr_t/uintptr_t exception

      - title: "Rule 11.8. A conversion shall not remove any const, volatile or _Atomic qualification from the type pointed to by a pointer"
        description: |
          Pointer conversions shall not remove const, volatile, or _Atomic qualifications from the pointed-to type.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Removing type qualifications can circumvent read-only status, bypass optimization constraints, or break atomic access guarantees, leading to undefined behavior.
        code_examples:
          # C examples
          - non_compliant: |
              const uint16_t *pci;
              volatile uint16_t *pvi;
              uint16_t *pi;
              uint16_t * const *pcpi;
              uint16_t **ppi;
              _Atomic struct s { uint8_t a; } astr;
              struct s *sptr;
              
              pi = (uint16_t *)pci;           // Non-compliant: removes const
              pi = (uint16_t *)pvi;           // Non-compliant: removes volatile
              ppi = (uint16_t **)pcpi;        // Non-compliant: removes const from pointer
              sptr = &astr;                   // Non-compliant: removes _Atomic

          - compliant: |
              uint16_t x;
              uint16_t * const cpi = &x;
              uint16_t *pi;
              const uint16_t *pci;
              volatile uint16_t *pvi;
              
              pi = cpi;                       // Compliant: no qualification removal
              pci = pi;                       // Compliant: adding qualification is allowed
              pvi = pi;                       // Compliant: adding qualification is allowed

      - title: "Rule 11.9. The macro NULL shall be the only permitted form of integer null pointer constant"
        description: |
          Integer constant expressions with value 0 used as null pointer constants shall be derived from the NULL macro expansion.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using NULL instead of literal 0 makes null pointer intent clear and improves code readability and maintainability.
        code_examples:
          # C examples
          - non_compliant: |
              int32_t *p1;
              #define MY_NULL_1 0
              
              p1 = 0;                         // Non-compliant: literal 0 instead of NULL
              if (p1 == MY_NULL_1) {}         // Non-compliant: custom null macro expanding to 0

          - compliant: |
              #include <stddef.h>
              int32_t *p1, *p2;
              #define MY_NULL_2 (void *)0
              
              p1 = NULL;                      // Compliant: standard NULL macro
              p2 = (void *)0;                 // Compliant: void pointer form allowed
              if (p2 == MY_NULL_2) {}         // Compliant: void pointer form
              int32_t arr[] = {0};            // Compliant: {0} initializer exception

      - title: "Rule 11.10. The _Atomic qualifier shall not be applied to the incomplete type void"
        description: |
          The _Atomic qualifier shall not be used with the incomplete void type.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using _Atomic with void type creates undefined behavior for pointer conversions and size/alignment assumptions, making code unpredictable.
        code_examples:
          # C examples
          - non_compliant: |
              struct A {
                  int32_t _Atomic x;
                  int32_t _Atomic y;
              };
              
              void main(void) {
                  struct A a1 = {6, 7};
                  void _Atomic *pav = &a1;    // Non-compliant: _Atomic void pointer
                  void _Atomic *pax = &a1.x;  // Non-compliant: _Atomic void pointer
              }

          - compliant: |
              struct A {
                  int32_t _Atomic x;
                  int32_t _Atomic y;
              };
              
              void main(void) {
                  struct A a1 = {6, 7};
                  void *pav = &a1;            // Compliant: regular void pointer
                  int32_t _Atomic *pax = &a1.x; // Compliant: _Atomic with complete type
              }

      - title: "Rule 11.11. Pointers shall not be implicitly compared to NULL"
        description: |
          Pointer expressions shall be explicitly compared to NULL rather than relying on implicit Boolean conversion.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Explicit NULL comparisons improve code clarity and follow the essential type model requiring Boolean expressions for Boolean contexts.
        code_examples:
          # C examples
          - non_compliant: |
              uint32_t *ptr;
              
              (bool)(ptr);                    // Non-compliant: implicit test for zero
              if (!ptr) {}                    // Non-compliant: implicit test for zero
              if (ptr && *ptr == 1) {}        // Non-compliant: implicit test for zero
              if (ptr) {}                     // Non-compliant: implicit test for zero

          - compliant: |
              uint32_t *ptr;
              
              (bool)(ptr != NULL);            // Compliant: explicit NULL comparison
              if (ptr != NULL) {}             // Compliant: explicit test for NULL
              if (ptr != NULL && *ptr == 1) {} // Compliant: explicit test for NULL

  - name: "5.12. Expressions"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 12.1a. The operand of the sizeof operator should be enclosed in parentheses"
        description: |
          The operand of the sizeof operator should be enclosed in parentheses.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Parenthesizing sizeof operands prevents ambiguity about what is being measured and makes code intention clear to reviewers and maintainers.
        code_examples:
          # C examples
          - non_compliant: |
              int32_t x, y;
              size_t size;
              
              size = sizeof x + y;            // Non-compliant: unclear if sizeof(x) + y or sizeof(x + y)
              size = sizeof x;                // Non-compliant: operand not parenthesized

          - compliant: |
              int32_t x, y;
              size_t size;
              
              size = sizeof(x) + y;           // Compliant: sizeof operand parenthesized
              size = sizeof(x + y);           // Compliant: alternative interpretation
              size = sizeof(int32_t);         // Compliant: type operand parenthesized

      - title: "Rule 12.1b. Expressions with precedence 2-12 should have explicit parentheses around operands"
        description: |
          Expressions with operator precedence 2-12 should have parentheses around operands that have precedence less than 13 and greater than the expression's precedence.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Explicit precedence prevents programmer mistakes with non-intuitive operator precedence and makes code intention clear to reviewers and maintainers, reducing maintenance errors.
        code_examples:
          # C examples
          - non_compliant: |
              int32_t a, b, c, x, y;
              
              x = a == b ? a : a - b;         // Non-compliant: conditional operator needs parentheses around operands
              x = a & b == c;                 // Non-compliant: unclear precedence between & and ==

          - compliant: |
              int32_t a, b, c, x, y;
              int32_t *p;
              int32_t i, n;
              
              x = (a == b) ? a : (a - b);     // Compliant: conditional operator operands parenthesized
              x = a & (b == c);               // Compliant: explicit precedence
              a[i]->n;                        // Compliant: no parentheses needed for precedence 15+ operators
              *p++;                           // Compliant: unary/postfix operators don't need extra parentheses
              x = a << (b + c);               // Compliant: shift operand parenthesized
              if (a && b && c) {}             // Compliant: same precedence operators don't need parentheses

      - title: "Rule 12.2. The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand"
        description: |
          The right operand of shift operators must be non-negative and less than the bit width of the left operand's essential type.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Shift amounts outside the valid range result in undefined behavior, potentially causing unpredictable program execution or security vulnerabilities.
        code_examples:
          # C examples
          - non_compliant: |
              uint8_t u8a = 1;
              uint16_t u16a;
              
              u8a = u8a << 8;                // Non-compliant: 8 >= width of uint8_t (8 bits)
              u8a = u8a >> -1;               // Non-compliant: negative shift amount
              1u << 10u;                     // Non-compliant: 1u is essentially unsigned char (8 bits)

          - compliant: |
              uint8_t u8a = 1;
              uint16_t u16a;
              
              u8a = u8a << 7;                // Compliant: 7 < 8 (width of uint8_t)
              u16a = (uint16_t)u8a << 9;     // Compliant: cast makes left operand 16-bit
              1UL << 10u;                    // Compliant: 1UL is essentially unsigned long

      - title: "Rule 12.3. The comma operator should not be used"
        description: |
          The comma operator should not be used.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using comma operators makes code harder to understand, especially in function calls where it's unclear how many parameters are being passed.
        code_examples:
          # C examples
          - non_compliant: |
              int i, N = 10;
              int a[10];
              int *p;
              
              f((1, 2), 3);                   // Non-compliant: unclear parameter count
              for (i = 0, p = &a[0]; i < N; ++i, ++p) {} // Non-compliant: comma in for loop

          - compliant: |
              int i, N = 10;
              int a[10];
              int *p;
              
              f(2, 3);                        // Compliant: clear parameter separation
              i = 0;                          // Compliant: separate statements
              p = &a[0];
              for (; i < N; ++i) {            // Compliant: avoid comma operator
                  ++p;
              }

      - title: "Rule 12.4. Evaluation of constant expressions should not lead to unsigned integer wrap-around"
        description: |
          Constant expressions should not cause unsigned integer wrap-around, as this is likely unintentional during compile-time evaluation.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Unintended wrap-around in constant expressions can lead to incorrect case labels, preprocessor conditions, and initialization values, causing logic errors.
        code_examples:
          # C examples
          - non_compliant: |
              #define BASE 65024u
              #define DELAY 10000u
              #define WIDTH 60000u
              bool_t b;
              
              switch (x) {
                  case BASE + 512u:           // Non-compliant: wraps to 0 on 16-bit systems
                      break;
              }
              
              #if 1u + (0u - 10u)            // Non-compliant: (0u - 10u) wraps
              #endif
              
              uint16_t off_time = DELAY + WIDTH; // Non-compliant: 70000 wraps on 16-bit systems
              uint16_t y = b ? 0u : (0u - 1u);   // Non-compliant: may evaluate wrap-around

          - compliant: |
              #define BASE 1000u
              #define DELAY 10000u
              #define WIDTH 20000u
              const uint16_t c = 0xffffu;
              
              switch (x) {
                  case BASE + 512u:           // Compliant: no wrap-around
                      break;
              }
              
              uint16_t off_time = DELAY + WIDTH;  // Compliant: sum within range
              uint16_t x = (0u == 0u) ? 0u : (0u - 1u); // Compliant: wrap-around not evaluated
              uint16_t z = c + 1u;            // Compliant: not a constant expression

      - title: "Rule 12.5. The sizeof operator shall not have an operand which is a function parameter declared as \"array of type\""
        description: |
          The sizeof operator shall not be applied to function parameters declared as arrays, as they decay to pointers and do not retain array size information.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using sizeof on array parameters returns the size of a pointer, not the array, leading to incorrect calculations and potential buffer overflows.
        code_examples:
          # C examples
          - non_compliant: |
              void f(int32_t A[4]) {
                  uint32_t numElements = sizeof(A) / sizeof(int32_t); // Non-compliant: A is pointer type
              }

          - compliant: |
              int32_t glbA[] = {1, 2, 3, 4, 5};
              
              void f(int32_t A[4]) {
                  uint32_t numElements_glbA = sizeof(glbA) / sizeof(glbA[0]); // Compliant: global array
              }
              
              void g(void) {
                  int32_t localA[] = {1, 2, 3};
                  uint32_t numElements = sizeof(localA) / sizeof(localA[0]); // Compliant: local array
              }

      - title: "Rule 12.6. Structure and union members of atomic objects shall not be directly accessed"
        description: |
          Atomic objects of structure and union types shall only be accessed as complete objects using atomic functions or assignment operator, not via member access operators.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Direct member access on atomic objects circumvents atomic protection mechanisms, creating data races and undefined behavior in multi-threaded programs.
        code_examples:
          # C examples
          - non_compliant: |
              typedef struct s {
                  uint8_t a;
                  uint8_t b;
              } s_t;
              _Atomic s_t astr;
              
              int32_t main(void) {
                  astr.b = 43U;               // Non-compliant: direct member access
                  return 0;
              }

          - compliant: |
              typedef struct s {
                  uint8_t a;
                  uint8_t b;
              } s_t;
              _Atomic s_t astr;
              
              int32_t main(void) {
                  s_t lstr = {7U, 42U};
                  lstr = atomic_load(&astr);  // Compliant: atomic access function
                  lstr.b = 43U;               // Compliant: local struct modification
                  atomic_store(&astr, lstr);  // Compliant: atomic store
                  astr = lstr;                // Compliant: assignment operator
                  return 0;
              }

  - name: "5.13. Side effects"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 13.1. Initializer lists shall not contain persistent side effects"
        description: |
          Initializer lists for automatic objects and compound literals shall not contain expressions with persistent side effects.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Persistent side effects in initializers can lead to unpredictable behavior due to unspecified evaluation order, making program behavior non-deterministic.
        code_examples:
          # C examples
          - non_compliant: |
              volatile uint16_t v1;
              uint16_t x = 0u;
              extern void p(uint16_t a[2]);
              
              void f(void) {
                  uint16_t a[2] = { v1, 0 };  // Non-compliant: volatile access is persistent side effect
              }
              
              void h(void) {
                  p((uint16_t[2]) { x++, x++ }); // Non-compliant: two side effects
              }

          - compliant: |
              void g(uint16_t x, uint16_t y) {
                  uint16_t a[2] = { x + y, x - y }; // Compliant: no side effects
              }

      - title: "Rule 13.2a. Objects shall not be modified more than once or both modified and read between sequence points"
        description: |
          Between sequence points, no object shall be modified more than once, and no object shall be both modified and read unless the read contributes to computing the value being stored.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Violating sequence point rules leads to undefined behavior due to unspecified evaluation order, making program behavior unpredictable and implementation-dependent.
        code_examples:
          # C examples
          - non_compliant: |
              uint16_t i = 0;
              int32_t a[10], b[10];
              
              #define COPY_ELEMENT(index) (a[(index)] = b[(index)])
              COPY_ELEMENT(i++);              // Non-compliant: i read and modified twice
              
              f(i++, i);                      // Non-compliant: i modified and read
              
              i = i++;                        // Non-compliant: i modified twice

          - compliant: |
              uint16_t i = 0;
              int32_t a[10], b[10];
              
              a[i] = b[i];                    // Compliant: separate statements
              i++;
              
              int temp = i;                   // Compliant: avoid simultaneous modification/read
              i++;
              f(temp, i);

      - title: "Rule 13.2b. Volatile and atomic objects shall not be accessed multiple times between sequence points"
        description: |
          Between sequence points, there shall be at most one modification access to volatile or atomic objects, and at most one read access to volatile or atomic objects.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Multiple accesses to volatile or atomic objects can lead to inconsistent values and data races in multi-threaded environments, undermining thread safety guarantees.
        code_examples:
          # C examples
          - non_compliant: |
              extern volatile uint16_t v1, v2;
              extern volatile uint8_t PORT;
              _Atomic int32_t a;
              
              uint16_t t = v1 + v2;           // Non-compliant: unspecified order of volatile reads
              
              int32_t result = a - a;         // Non-compliant: atomic object read twice

          - compliant: |
              extern volatile uint16_t v1, v2;
              extern volatile uint8_t PORT;
              _Atomic int32_t a;
              
              PORT = PORT & 0x80u;            // Compliant: single volatile read and write
              
              int32_t acopy = a;              // Compliant: store atomic value locally
              int32_t v2 = acopy - acopy;     // Compliant: local variable used twice

      - title: "Rule 13.3. A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator"
        description: |
          Full expressions containing increment or decrement operators should not have other side effects including function calls, even in unevaluated sub-expressions.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Combining increment/decrement with other side effects impairs readability and can introduce undefined behavior due to unspecified evaluation order.
        code_examples:
          # C examples
          - non_compliant: |
              uint8_t u8a, u8b, u8c;
              extern int f(void);
              extern void g(uint8_t);
              bool bool_var;
              
              u8a = u8b++;                    // Non-compliant: assignment and increment
              u8a = ++u8b + u8c--;            // Non-compliant: multiple side effects
              if ((f() + --u8a) == 0u) {}     // Non-compliant: function call and decrement
              g(u8b++);                       // Non-compliant: function call and increment
              u8a = (1u == 1u) ? 0u : u8b++;  // Non-compliant: even if not evaluated

          - compliant: |
              uint8_t u8a, u8b, u8c;
              int x = 0, i = 5;
              int a[10];
              struct { int x; } b;
              int *p = &x;
              
              x++;                            // Compliant: only increment
              a[i]++;                         // Compliant: only increment
              b.x++;                          // Compliant: only increment
              ++(*p);                         // Compliant: only increment
              
              ++u8b;                          // Compliant: separate statements
              u8a = u8b + u8c;
              u8c--;

      - title: "Rule 13.4. The result of an assignment operator should not be used"
        description: |
          The result value of assignment operators should not be used in expressions, even in unevaluated sub-expressions.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using assignment results in expressions significantly impairs code readability and introduces additional side effects that can lead to undefined behavior.
        code_examples:
          # C examples
          - non_compliant: |
              int x, y, a[10], b, c;
              bool bool_var;
              extern int f(void);
              
              a[x] = a[x = y];                // Non-compliant: value of x = y is used
              if (bool_var = false) {}        // Non-compliant: assignment instead of comparison
              if ((0u == 0u) || (bool_var = true)) {} // Non-compliant: even if not evaluated
              if ((x = f()) != 0) {}          // Non-compliant: value of x = f() is used
              a[b += c] = a[b];               // Non-compliant: value of b += c is used
              a = b = c = 0;                  // Non-compliant: chained assignments

          - compliant: |
              int x, y, a[10], b, c;
              bool bool_var;
              extern int f(void);
              
              x = y;                          // Compliant: simple assignment
              if (bool_var == false) {}       // Compliant: comparison operator
              x = f();                        // Compliant: separate statements
              if (x != 0) {}
              b += c;                         // Compliant: separate statements
              a[b] = a[b];

      - title: "Rule 13.5. The right hand operand of a logical && or || operator shall not contain persistent side effects"
        description: |
          The right operand of logical AND (&&) and OR (||) operators shall not contain persistent side effects.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Persistent side effects in right operands may or may not occur depending on left operand evaluation, leading to unpredictable program behavior.
        code_examples:
          # C examples
          - non_compliant: |
              volatile uint16_t v;
              uint16_t x, a;
              bool ishigh;
              
              uint16_t h(uint16_t y) {        // Function with persistent side effects
                  static uint16_t temp = 0;
                  temp = y + temp;            // Modifies static variable
                  return temp;
              }
              
              if ((x == 0u) || (v == 1u)) {}  // Non-compliant: volatile access is persistent
              if (ishigh && (a == h(x))) {}   // Non-compliant: h() has persistent side effects

          - compliant: |
              uint16_t x, a;
              bool ishigh;
              
              uint16_t f(uint16_t y) {        // Function without persistent side effects
                  uint16_t temp = y;
                  temp = y + 0x8080U;         // Only modifies local variable
                  return temp;
              }
              
              if (ishigh && (a == f(x))) {}   // Compliant: f() has no persistent side effects

      - title: "Rule 13.6. The operand of the sizeof operator shall not contain any expression which has potential side effects"
        description: |
          The sizeof operator's operand shall not contain expressions with side effects.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Side effects in sizeof operands may or may not occur, creating unpredictable behavior and potential programming errors when side effects are expected.
        code_examples:
          # C examples
          - non_compliant: |
              volatile int32_t i;
              volatile uint32_t v;
              int32_t j;
              size_t s;
              
              s = sizeof(j++);                // Non-compliant: increment side effect
              
              void f(int32_t n) {
                  s = sizeof(int32_t[n++]);   // Non-compliant: increment in VLA size
                  s = sizeof(void (*[n])(int32_t a[v])); // Non-compliant: volatile access
              }

          - compliant: |
              volatile int32_t i;
              int32_t j;
              size_t s;
              
              s = sizeof(j);                  // Compliant: no side effects
              s = sizeof(i);                  // Compliant: exception for volatile lvalue
              s = sizeof(int32_t);            // Compliant: type operand
              
              void f(int32_t n) {
                  s = sizeof(int32_t[n]);     // Compliant: no side effects in VLA size
              }

  - name: "5.14. Control statement expressions"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 14.1. A loop counter shall not have essentially floating type"
        description: |
          Loop counters shall not have essentially floating type.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Floating-point rounding errors can cause loops to execute a different number of iterations than expected, leading to incorrect program behavior that varies across implementations.
        code_examples:
          # C examples
          - non_compliant: |
              uint32_t counter = 0u;
              float f;
              
              for (f = 0.0f; f < 1.0f; f += 0.001f) {  // Non-compliant: floating-point loop counter
                  ++counter;
              }
              
              f = 0.0f;
              while (f < 1.0f) {              // Non-compliant: f is loop counter
                  f += 0.001f;
              }

          - compliant: |
              float f;
              uint32_t u32a;
              
              for (uint32_t counter = 0u; counter < 1000u; ++counter) { // Compliant: integer loop counter
                  f = (float)counter * 0.001f;
              }
              
              f = read_float();
              do {
                  u32a = read_u32();
                  // f does not change so is not a loop counter
              } while (((float)u32a - f) > 10.0f);    // Compliant: f not a loop counter

      - title: "Rule 14.2a. For loop first clause shall only set the loop counter"
        description: |
          The first clause of a for loop shall be empty, or set only the loop counter value, or define and initialize the loop counter.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Restricting the first clause ensures clear loop initialization and prevents complex side effects that could make the loop behavior unpredictable.
        code_examples:
          # C examples
          - non_compliant: |
              int i, j;
              
              for (i = 0, j = 0; i < 10; i++) {}   // Non-compliant: multiple initializations
              for (i = init_func(); i < 10; i++) {} // Non-compliant: function call with side effects

          - compliant: |
              int i, j;
              
              for (i = 0; i < 10; i++) {}          // Compliant: single loop counter initialization
              for (int k = 0; k < 10; k++) {}      // Compliant: loop counter definition and initialization
              for (;;) {}                          // Compliant: empty clause

      - title: "Rule 14.2b. For loop second clause shall have no persistent side effects"
        description: |
          The second clause of a for loop shall be an expression with no persistent side effects, using only the loop counter and optionally loop control flags.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Ensuring no side effects in the condition clause prevents unpredictable loop behavior and makes the termination condition clear and deterministic.
        code_examples:
          # C examples
          - non_compliant: |
              bool_t flag;
              int i;
              extern int get_limit(void);
              
              for (i = 0; i < get_limit(); i++) {}  // Non-compliant: function call with side effects
              for (i = 0; i < (flag = true, 10); i++) {} // Non-compliant: assignment side effect

          - compliant: |
              bool_t flag = false;
              int i, limit = 10;
              
              for (i = 0; (i < limit) && !flag; i++) {} // Compliant: uses loop counter and control flag
              for (i = 0; i < 10; i++) {}               // Compliant: simple condition with loop counter

      - title: "Rule 14.2c. For loop third clause shall only modify the loop counter"
        description: |
          The third clause of a for loop shall be an expression whose only persistent side effect is to modify the loop counter value.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Restricting the third clause to only modify the loop counter ensures predictable loop progression and prevents unintended side effects during iteration.
        code_examples:
          # C examples
          - non_compliant: |
              int i, j;
              
              for (i = 0; i < 10; i++, j++) {}     // Non-compliant: modifying multiple variables
              for (i = 0; i < 10; i++, func()) {} // Non-compliant: function call with side effects

          - compliant: |
              int i;
              
              for (i = 0; i < 10; i++) {}          // Compliant: only loop counter modified
              for (i = 0; i < 10; ++i) {}          // Compliant: pre-increment of loop counter
              for (i = 10; i > 0; --i) {}          // Compliant: decrement of loop counter

      - title: "Rule 14.2d. For loop shall have only one loop counter that is not modified in the loop body"
        description: |
          A for loop shall have only one loop counter, which shall not be modified anywhere in the loop body.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Having a single unmodified loop counter ensures predictable loop behavior and prevents confusion about loop progression and termination.
        code_examples:
          # C examples
          - non_compliant: |
              bool_t flag = false;
              
              for (int i = 0; (i < 5) && !flag; i++) {
                  if (condition) {
                      flag = true;
                  }
                  i = i + 3;                  // Non-compliant: modifying loop counter in body
              }

          - compliant: |
              bool_t flag = false;
              
              for (int i = 0; (i < 5) && !flag; i++) {
                  if (condition) {
                      flag = true;            // Compliant: modifying control flag, not loop counter
                  }
                  // i not modified in body
              }
              
              for (;;) {}                     // Compliant: infinite loop exception

      - title: "Rule 14.3. Controlling expressions shall not be invariant"
        description: |
          Controlling expressions of if, while, for, do-while, switch statements and conditional operators shall not have invariant values.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Invariant controlling expressions may indicate programming errors and can cause unreachable code that might be removed by compilers, potentially eliminating defensive code.
        code_examples:
          # C examples
          - non_compliant: |
              uint16_t u16a;
              int8_t s8a;
              const uint8_t numcyl = 4u;
              
              s8a = (u16a < 0u) ? 0 : 1;      // Non-compliant: u16a always >= 0
              if (u16a <= 0xffffu) {}         // Non-compliant: always true
              if (2 > 3) {}                   // Non-compliant: always false
              for (s8a = 0; s8a < 130; ++s8a) {} // Non-compliant: s8a range exceeded
              if ((s8a < 10) && (s8a > 20)) {} // Non-compliant: always false
              if (numcyl == 4u) {}            // Non-compliant: const always has value 4
              do {} while (0u == 1u);         // Non-compliant: not Boolean false

          - compliant: |
              const volatile uint8_t numcyl_cal = 4u;
              int8_t s8a;
              
              while (true) {}                 // Compliant: exception for infinite loop
              do {} while (false);            // Compliant: exception for single iteration
              for (;;) {}                     // Compliant: exception for infinite loop
              if (numcyl_cal == 4u) {}        // Compliant: volatile may change externally

      - title: "Rule 14.4. The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type"
        description: |
          Controlling expressions of if statements and iteration statements shall have essentially Boolean type.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Requiring Boolean controlling expressions prevents implicit conversions that can lead to unexpected behavior and improves code clarity and type safety.
        code_examples:
          # C examples
          - non_compliant: |
              int32_t *p;
              int32_t i;
              
              while (p) {}                    // Non-compliant: p is pointer type
              if (i) {}                       // Non-compliant: i is integer type

          - compliant: |
              int32_t *p, *q;
              int32_t i;
              extern bool_t flag;
              
              while (q != NULL) {}            // Compliant: comparison yields Boolean
              while (true) {}                 // Compliant: Boolean literal
              while (flag) {}                 // Compliant: Boolean variable
              if (i != 0) {}                  // Compliant: comparison yields Boolean

  - name: "5.15. Control flow"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 15.1. The goto statement should not be used"
        description: |
          The goto statement should be avoided.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Unconstrained goto usage creates unstructured code that is difficult to understand, maintain, and debug, though restricted use following specific rules may be acceptable.
        code_examples:
          # C examples
          - non_compliant: |
              void f(void) {
                  int32_t i = 0;
              start:
                  if (i < 10) {
                      ++i;
                      goto start;             // Non-compliant: goto usage
                  }
              }

          - compliant: |
              void f(void) {
                  for (int32_t i = 0; i < 10; ++i) { // Compliant: structured loop instead of goto
                      // process
                  }
              }

      - title: "Rule 15.2. The goto statement shall jump to a label declared later in the same function"
        description: |
          If goto statements are used, they shall only jump forward to labels declared later in the same function, prohibiting backward jumps.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Restricting goto to forward jumps only prevents creation of ad-hoc loops and ensures that proper iteration statements are used, reducing visual code complexity.
        code_examples:
          # C examples
          - non_compliant: |
              void f(void) {
                  int32_t j = 0;
              L1:
                  ++j;
                  if (10 == j) {
                      goto L2;
                  }
                  goto L1;                    // Non-compliant: backward jump
              L2:
                  ++j;
              }

          - compliant: |
              void f(void) {
                  int32_t j = 0;
                  while (j < 10) {            // Compliant: proper iteration statement
                      ++j;
                  }
                  goto L2;                    // Compliant: forward jump
              L2:
                  ++j;
              }

      - title: "Rule 15.3. Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement"
        description: |
          Labels referenced by goto statements shall be in the same block or an enclosing block.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Preventing jumps between blocks or into nested blocks minimizes visual code complexity and maintains structured control flow within functions.
        code_examples:
          # C examples
          - non_compliant: |
              void f1(int32_t a) {
                  if (a <= 0) {
                      goto L2;                // Non-compliant: jump into nested block
                  }
                  goto L1;
                  if (a == 0) {
                      goto L1;
                  }
                  goto L2;                    // Non-compliant: jump into nested block
              L1:
                  if (a > 0) {
              L2:
                      ;
                  }
              }
              
              void f2(int x, int y) {
                  switch (x) {
                      case 0:
                          if (x == y) {
                              goto L1;        // Non-compliant: jump between switch clauses
                          }
                          break;
                      case 1:
                          y = x;
                  L1:
                          ++x;
                          break;
                      default:
                          break;
                  }
              }

          - compliant: |
              void f1(int32_t a) {
                  goto L1;                    // Compliant: same block
                  if (a == 0) {
                      goto L1;                // Compliant: enclosing block
                  }
              L1:
                  if (a > 0) {
                      // no jumps across block boundaries
                  }
              }

      - title: "Rule 15.4. There should be no more than one break or goto statement used to terminate any iteration statement"
        description: |
          Iteration statements should have no more than one break or goto statement for early termination.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Restricting exit points from loops minimizes visual code complexity and allows a single secondary exit path when early loop termination is required.
        code_examples:
          # C examples
          - non_compliant: |
              for (int x = 0; x < LIMIT; ++x) {
                  if (BreakNow(x)) {
                      break;                  // Non-compliant: multiple exit statements
                  } else if (GotoNow(x)) {
                      goto EXIT;              // Non-compliant: second exit statement
                  }
              }
              EXIT:
                  ;

          - compliant: |
              for (int x = 0; x < LIMIT; ++x) {
                  if (ExitNow(x)) {
                      break;                  // Compliant: single exit statement
                  }
              }

      - title: "Rule 15.5. A function should have a single point of exit at the end"
        description: |
          Functions should have no more than one return statement, positioned as the final statement in the function body.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Single exit points support the modular approach encouraged by functional safety standards and make it easier to determine which side effects will occur.
        code_examples:
          # C examples
          - non_compliant: |
              bool f(uint16_t n, char *p) {
                  if (n > MAX) { return false; }   // Non-compliant: early return
                  if (p == NULL) { return false; } // Non-compliant: early return
                  return true;
              }

          - compliant: |
              bool f(uint16_t n, char *p) {
                  bool result = true;
                  if (n > MAX) {
                      result = false;
                  } else if (p == NULL) {
                      result = false;
                  }
                  return result;              // Compliant: single exit point
              }

      - title: "Rule 15.6. The body of an iteration-statement or a selection-statement shall be a compound-statement"
        description: |
          The body of iteration statements (while, do-while, for) and selection statements (if, else, switch) shall always be a compound statement enclosed in braces.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using compound statements prevents developer mistakes with indentation assumptions, accidental semicolons creating null statements, and ambiguous else associations.
        code_examples:
          # C examples
          - non_compliant: |
              while (data_available)
                  process_data();             // Non-compliant: missing braces
              
              if (flag_1)
                  if (flag_2)                 // Non-compliant: missing braces
                      action_1();             // Non-compliant: missing braces
              else
                  action_2();                 // Non-compliant: missing braces

          - compliant: |
              while (data_available) {
                  process_data();             // Compliant: compound statement
              }
              
              if (flag_1) {
                  if (flag_2) {               // Compliant: compound statement
                      action_1();
                  } else {
                      action_2();
                  }
              }

      - title: "Rule 15.7. All if ... else if constructs shall be terminated with an else statement"
        description: |
          Every if statement followed by one or more else if constructs shall be terminated with a final else statement containing at least a side effect or comment.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Terminating else statements provide defensive programming and explicit indication of desired behavior when no conditions are met, aiding code review.
        code_examples:
          # C examples
          - non_compliant: |
              if (flag_1) {
                  action_1();
              } else if (flag_2) {
                  action_2();
              }                               // Non-compliant: missing terminating else

          - compliant: |
              if (flag_1) {
                  action_1();
              } else if (flag_2) {
                  action_2();
              } else {
                  // No action required       // Compliant: explicit terminating else
              }

  - name: "5.16. Switch statements"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 16.1. All switch statements shall be well-formed"
        description: |
          Switch statements shall conform to a well-defined syntax with proper case and default label placement.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Well-formed switch statements prevent complex, unstructured behavior and impose a simple and consistent structure on switch statements.
        code_examples:
          # C examples
          - non_compliant: |
              switch (x) {
                  case 1:
                      if (flag) {
              case 2:                         // Non-compliant: case label in nested block
                          x = 1;
                      }
                      break;
                  default:
                      break;
              }

          - compliant: |
              switch (x) {
                  case 1:                     // Compliant: proper case label placement
                      if (flag) {
                          x = 1;
                      }
                      break;
                  case 2:
                      x = 2;
                      break;
                  default:
                      break;
              }

      - title: "Rule 16.2. A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement"
        description: |
          Switch labels (case or default) shall only appear at the outermost level of the compound statement forming the body of a switch statement.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Restricting switch label placement prevents unstructured code and ensures labels only appear where they belong in switch statement bodies.
        code_examples:
          # C examples
          - non_compliant: |
              switch (x) {
                  case 1:
                      if (flag) {
              case 2:                         // Non-compliant: switch label in nested statement
                          x = 1;
                      }
                      break;
                  default:
                      break;
              }

          - compliant: |
              switch (x) {
                  case 1:                     // Compliant: switch label at outermost level
                      if (flag) {
                          x = 1;
                      }
                      break;
                  case 2:                     // Compliant: switch label at outermost level
                      x = 2;
                      break;
                  default:
                      break;
              }

      - title: "Rule 16.3. Every switch-clause shall be appropriately terminated"
        description: |
          Each switch clause shall be terminated by a jump statement (goto, break, continue, return) or a call to a _Noreturn-qualified function.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Proper termination prevents unintentional fall-through into subsequent switch clauses, which is often an error that can be difficult to detect.
        code_examples:
          # C examples
          - non_compliant: |
              switch (x) {
                  case 0:
                      break;
                  case 1:
                      a = b;                  // Non-compliant: missing termination
                  case 2:
                      if (a == b) {
                          ++a;
                          break;              // Non-compliant: conditional termination
                      }
                  default:
                      ;                       // Non-compliant: default not terminated
              }

          - compliant: |
              switch (x) {
                  case 0:
                      break;                  // Compliant: unconditional break
                  case 1:                     // Compliant: empty fall-through
                  case 2:
                      a = b;
                      break;                  // Compliant: unconditional break
                  default:
                      /* no action */
                      break;                  // Compliant: default terminated
              }

      - title: "Rule 16.4. Every switch statement shall have a default label"
        description: |
          Switch statements shall always include a default label with either a statement or a comment to indicate intended behavior.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Default labels provide defensive programming by handling unexpected values and making explicit the intended behavior when no case matches.
        code_examples:
          # C examples
          - non_compliant: |
              int16_t x;
              switch (x) {
                  case 0:
                      ++x;
                      break;
                  case 1:
                  case 2:
                      break;
                  // Non-compliant: missing default label
              }

          - compliant: |
              int16_t x;
              switch (x) {
                  case 0:
                      ++x;
                      break;
                  case 1:
                  case 2:
                      break;
                  default:                    // Compliant: default label present
                      errorflag = 1;
                      break;
              }

      - title: "Rule 16.5. A default label shall appear as either the first or the last switch label of a switch statement"
        description: |
          The default label shall be positioned either as the first switch label or as the last switch label within a switch statement.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Consistent default label placement makes it easy to locate the default clause within switch statements, improving code readability and maintainability.
        code_examples:
          # C examples
          - non_compliant: |
              switch (x) {
                  case 0:
                      ++x;
                      break;
                  default:                    // Non-compliant: default mixed with cases
                      x = 0;
                      break;
                  case 1:
                  case 2:
                      break;
              }

          - compliant: |
              switch (x) {
                  default:                    // Compliant: default as first label
                      x = 0;
                      break;
                  case 0:
                      ++x;
                      break;
                  case 1:
                  case 2:
                      break;
              }

      - title: "Rule 16.6. Every switch statement shall have at least two switch-clauses"
        description: |
          Switch statements shall have at least two switch clauses.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Eliminating single-clause switch statements prevents redundant code and helps identify potential programming errors where other constructs would be more appropriate.
        code_examples:
          # C examples
          - non_compliant: |
              switch (x) {
                  default:                    // Non-compliant: switch is redundant
                      x = 0;
                      break;
              }
              
              switch (y) {
                  case 1:
                  default:                    // Non-compliant: single effective clause
                      y = 0;
                      break;
              }

          - compliant: |
              switch (z) {
                  case 1:                     // Compliant: multiple clauses
                      z = 2;
                      break;
                  default:
                      z = 0;
                      break;
              }

      - title: "Rule 16.7. A switch-expression shall not have essentially Boolean type"
        description: |
          Switch expressions shall not have essentially Boolean type; an if-else construct should be used instead for Boolean conditions.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using if-else for Boolean conditions is more logical and readable than switch statements, which are better suited for multi-value selections.
        code_examples:
          # C examples
          - non_compliant: |
              switch (x == 0) {               // Non-compliant: essentially Boolean
                  case false:
                      y = x;
                      break;
                  default:
                      y = z;
                      break;
              }

          - compliant: |
              if (x == 0) {                   // Compliant: if-else for Boolean
                  y = z;
              } else {
                  y = x;
              }

  - name: "5.17. Functions"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 17.1. The standard header file <stdarg.h> shall not be used"
        description: |
          The standard header file <stdarg.h> shall not be included, and none of its variadic argument features shall be used.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding <stdarg.h> prevents numerous instances of undefined behavior related to variadic functions, including improper va_end usage and type mismatches.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdarg.h>             // Non-compliant: prohibited header
              
              void f(uint16_t n, ...) {
                  va_list ap;                 // Non-compliant: va_list usage
                  va_start(ap, n);            // Non-compliant: va_start usage
                  uint32_t x = va_arg(ap, uint32_t); // Non-compliant: va_arg usage
              }

          - compliant: |
              void f(uint16_t n, uint32_t x, uint32_t y) { // Compliant: fixed parameters
                  // Process fixed parameters instead of variadic
              }

      - title: "Rule 17.2. Functions shall not call themselves, either directly or indirectly"
        description: |
          Functions shall not call themselves recursively, either directly or through a call chain.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Preventing recursion eliminates the danger of exceeding available stack space and makes worst-case stack usage determinable before execution.
        code_examples:
          # C examples
          - non_compliant: |
              int factorial(int n) {
                  if (n <= 1) return 1;
                  return n * factorial(n - 1); // Non-compliant: direct recursion
              }
              
              void funcA(void) { funcB(); }
              void funcB(void) { funcA(); }   // Non-compliant: indirect recursion

          - compliant: |
              int factorial(int n) {          // Compliant: iterative approach
                  int result = 1;
                  for (int i = 2; i <= n; i++) {
                      result *= i;
                  }
                  return result;
              }

      - title: "Rule 17.3. A function shall not be declared implicitly"
        description: |
          Functions shall have explicit declarations visible before use.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Explicit function declarations ensure proper argument and return type checking, preventing inappropriate type conversions and undefined behavior.
        code_examples:
          # C examples
          - non_compliant: |
              void func(void) {
                  double sq1 = power(1, 2.0); // Non-compliant: power not declared
              }

          - compliant: |
              extern double power(double d, int n); // Compliant: explicit declaration
              
              void func(void) {
                  double sq1 = power(1.0, 2); // Compliant: declaration visible
              }

      - title: "Rule 17.4. All exit paths from a function with non-void return type shall have an explicit return statement with an expression"
        description: |
          Non-void functions shall have explicit return statements with expressions on all exit paths.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Explicit return statements with expressions ensure that calling functions receive valid return values, preventing undefined behavior when return values are used.
        code_examples:
          # C examples
          - non_compliant: |
              int32_t absolute(int32_t v) {
                  if (v < 0) {
                      return -v;
                  }
                  // Non-compliant: missing return on this path
              }
              
              uint16_t lookup(uint16_t v) {
                  if ((v < V_MIN) || (v > V_MAX)) {
                      return;                 // Non-compliant: no expression
                  }
                  return table[v];
              }

          - compliant: |
              int32_t absolute(int32_t v) {   // Compliant: all paths return
                  if (v < 0) {
                      return -v;
                  } else {
                      return v;
                  }
              }
              
              uint16_t lookup(uint16_t v) {
                  if ((v < V_MIN) || (v > V_MAX)) {
                      return 0;               // Compliant: expression provided
                  }
                  return table[v];
              }

      - title: "Rule 17.5. The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements"
        description: |
          Function arguments shall point to objects with at least as many elements as specified by array parameters.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Ensuring proper array sizes prevents buffer overflows and undefined behavior when functions access array elements beyond the actual array bounds.
        code_examples:
          # C examples
          - non_compliant: |
              void fn1(int32_t array1[4]);    // Expects 4 elements
              
              void caller(void) {
                  int32_t arr3[3] = {1, 2, 3};
                  fn1(arr3);                  // Non-compliant: only 3 elements
              }

          - compliant: |
              void fn1(int32_t array1[4]);    // Expects 4 elements
              void fn2(int32_t array2[]);     // Handles any size
              
              void caller(void) {
                  int32_t arr4[4] = {0, 1, 2, 3};
                  fn1(arr4);                  // Compliant: correct size
                  fn2(arr4);                  // Compliant: flexible size
              }

      - title: "Rule 17.7. The value returned by a function having non-void return type shall be used"
        description: |
          Return values from non-void functions shall be used; if intentionally discarded, they shall be explicitly cast to void.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Ensuring return values are used prevents errors where important function results are accidentally ignored; explicit void casts document intentional discard.
        code_examples:
          # C examples
          - non_compliant: |
              uint16_t func(uint16_t para1) {
                  return para1;
              }
              
              void discarded(uint16_t para2) {
                  func(para2);                // Non-compliant: value discarded
              }

          - compliant: |
              uint16_t func(uint16_t para1) {
                  return para1;
              }
              
              void discarded(uint16_t para2) {
                  (void)func(para2);          // Compliant: explicit discard
                  uint16_t x = func(para2);   // Compliant: value used
              }

      - title: "Rule 17.8. A function parameter should not be modified"
        description: |
          Function parameters should not be modified within the function body.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding parameter modification prevents confusion, especially for programmers from other languages, and makes code behavior more predictable and easier to understand.
        code_examples:
          # C examples
          - non_compliant: |
              int16_t glob = 0;
              
              void proc(int16_t para) {
                  para = glob;                // Non-compliant: parameter modified
              }
              
              void f(char *p, char *q) {
                  p = q;                      // Non-compliant: parameter modified
              }

          - compliant: |
              int16_t glob = 0;
              
              void proc(int16_t para) {
                  int16_t local = para;       // Compliant: copy to local variable
                  local = glob;
              }
              
              void f(char *p, char *q) {
                  *p = *q;                    // Compliant: modifying pointed-to data
              }

      - title: "Rule 17.9. A function declared with a _Noreturn function specifier shall not return to its caller"
        description: |
          Functions declared with _Noreturn shall never return to their caller by any execution path.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Ensuring _Noreturn functions never return prevents undefined behavior and maintains the contract established by the function specifier.
        code_examples:
          # C examples
          - non_compliant: |
              _Noreturn void a(void) {
                  return;                     // Non-compliant: breaks _Noreturn contract
              }
              
              _Noreturn void d(int32_t i) {
                  if (i > 0) {
                      abort();
                  }
                  // Non-compliant: returns if i <= 0
              }

          - compliant: |
              _Noreturn void b(void) {
                  while (true) {              // Compliant: never returns
                      // process
                  }
              }
              
              _Noreturn void c(void) {
                  abort();                    // Compliant: abort never returns
              }

      - title: "Rule 17.10. A function declared with a _Noreturn function specifier shall have void return type"
        description: |
          Functions declared with _Noreturn shall have void return type.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Ensuring _Noreturn functions have void return type maintains logical consistency since functions that never return cannot provide return values.
        code_examples:
          # C examples
          - non_compliant: |
              _Noreturn int32_t f(void);      // Non-compliant: non-void return type

          - compliant: |
              _Noreturn void g(void);         // Compliant: void return type

      - title: "Rule 17.11. A function that never returns should be declared with a _Noreturn function specifier"
        description: |
          Functions that never return to their caller should be declared with the _Noreturn function specifier to clearly indicate this design intent.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Declaring non-returning functions as _Noreturn highlights the design intent and enables compiler optimizations while documenting expected behavior.
        code_examples:
          # C examples
          - non_compliant: |
              void f(void) {                  // Non-compliant: should be _Noreturn
                  exit(0);
              }

          - compliant: |
              _Noreturn void f(void) {        // Compliant: explicit _Noreturn
                  exit(0);
              }

      - title: "Rule 17.12. A function identifier should only be used with either a preceding &, or with a parenthesized parameter list"
        description: |
          Function identifiers should be used either with the address-of operator (&) or with parentheses for function calls.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Clear function usage prevents confusion about whether the intent is to call the function or obtain its address, improving code readability and preventing errors.
        code_examples:
          # C examples
          - non_compliant: |
              typedef int32_t (*pfn_i)(void);
              extern int32_t func1(void);
              
              void func(void) {
                  pfn_i pfn2 = func1;         // Non-compliant: ambiguous intent
                  if (func1 == pfn2) {        // Non-compliant: ambiguous comparison
                      // ...
                  }
              }

          - compliant: |
              typedef int32_t (*pfn_i)(void);
              extern int32_t func1(void);
              
              void func(void) {
                  pfn_i pfn1 = &func1;        // Compliant: explicit address
                  int32_t result = func1();   // Compliant: explicit call
                  if (&func1 == pfn1) {       // Compliant: explicit address comparison
                      // ...
                  }
              }

      - title: "Rule 17.13. A function type shall not be type qualified"
        description: |
          Function types shall not include type qualifiers (const, volatile, restrict, _Atomic) as this results in undefined behavior.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding type qualifiers on function types prevents undefined behavior and ensures consistent function type specifications across the codebase.
        code_examples:
          # C examples
          - non_compliant: |
              typedef uint16_t ftype(void);
              typedef const ftype cftype;     // Non-compliant: const-qualified function type

          - compliant: |
              typedef uint16_t ftype(void);
              typedef ftype dftype;           // Compliant: unqualified function type
              typedef ftype * const pcftype;  // Compliant: const pointer to function
              const uint16_t cf(void);        // Compliant: const return type

  - name: "5.18. Pointers and arrays"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 18.1. A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand"
        description: |
          Pointer arithmetic shall only result in pointers that address elements within the same array or one element beyond the end of that array.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Restricting pointer arithmetic to array boundaries prevents undefined behavior from invalid array subscripts and ensures memory safety in array operations.
        code_examples:
          # C examples
          - non_compliant: |
              void f2(void) {
                  int32_t c[10] = {0};
                  int32_t d[5][2] = {0};
                  
                  int32_t *p3 = &c[11];       // Non-compliant: points two beyond
                  int32_t data = c[10];       // Non-compliant: one beyond dereference
                  c[-1] = 0;                  // Non-compliant: negative index
                  data = d[2][3];             // Non-compliant: internal boundary exceeded
              }

          - compliant: |
              void f2(void) {
                  int32_t c[10] = {0};
                  int32_t d[5][2] = {0};
                  
                  int32_t *p1 = &c[0];        // Compliant: within array
                  int32_t *p2 = &c[10];       // Compliant: one beyond (no dereference)
                  int32_t data = c[9];        // Compliant: valid index
                  d[3][1] = 0;                // Compliant: within bounds
                  data = *(*(d + 3) + 1);     // Compliant: valid pointer arithmetic
              }

      - title: "Rule 18.2. Subtraction between pointers shall only be applied to pointers that address elements of the same array"
        description: |
          Pointer subtraction shall only be performed between pointers that address elements of the same array or one element beyond the end of that array.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Restricting pointer subtraction to the same array prevents undefined behavior that occurs when subtracting pointers from different objects or arrays.
        code_examples:
          # C examples
          - non_compliant: |
              void f1(int32_t *ptr) {
                  int32_t a1[10];
                  int32_t a2[10];
                  int32_t *p1 = &a1[1];
                  int32_t *p2 = &a2[10];
                  
                  ptrdiff_t diff = p1 - p2;   // Non-compliant: different arrays
                  diff = ptr - p1;            // Non-compliant: unknown relationship
              }

          - compliant: |
              void f1(int32_t *ptr) {
                  int32_t a1[10];
                  int32_t *p1 = &a1[1];
                  int32_t *p2 = &a1[10];
                  
                  ptrdiff_t diff = p1 - a1;   // Compliant: same array
                  diff = p2 - a1;             // Compliant: same array
              }

      - title: "Rule 18.3. The relational operators >, >=, < and <= shall not be applied to expressions of pointer type except where they point into the same object"
        description: |
          Relational operators for pointers shall only be used when comparing pointers that point into the same object or array.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Restricting pointer comparisons to the same object prevents undefined behavior that occurs when comparing pointers to different objects.
        code_examples:
          # C examples
          - non_compliant: |
              void f1(void) {
                  int32_t a1[10];
                  int32_t a2[10];
                  int32_t *p1 = a1;
                  
                  if (p1 < a2) {              // Non-compliant: different arrays
                      // process
                  }
              }
              
              void f2(void) {
                  struct { int32_t lwb; int32_t upb; } limits_1, limits_2;
                  if (&limits_1.lwb > &limits_2.upb) { // Non-compliant: different objects
                      // process
                  }
              }

          - compliant: |
              void f1(void) {
                  int32_t a1[10];
                  int32_t *p1 = a1;
                  
                  if (p1 < &a1[9]) {          // Compliant: same array
                      // process
                  }
              }
              
              void f2(void) {
                  struct { int32_t lwb; int32_t upb; } limits_1;
                  if (&limits_1.lwb <= &limits_1.upb) { // Compliant: same object
                      // process
                  }
              }

      - title: "Rule 18.4. The +, -, += and -= operators should not be applied to an expression of pointer type"
        description: |
          Pointer arithmetic operators (+, -, +=, -=) should be avoided in favor of array subscript syntax.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using array subscript syntax instead of explicit pointer arithmetic improves code clarity, reduces errors, and makes manual review easier.
        code_examples:
          # C examples
          - non_compliant: |
              void fn1(void) {
                  uint8_t a[10];
                  uint8_t *ptr = a;
                  
                  *(ptr + 5) = 0U;            // Non-compliant: pointer arithmetic
                  ptr = ptr + 3;              // Non-compliant: pointer arithmetic
                  ptr += 2;                   // Non-compliant: pointer arithmetic
              }

          - compliant: |
              void fn1(void) {
                  uint8_t a[10];
                  uint8_t *ptr = a;
                  
                  ptr[5] = 0U;                // Compliant: array subscript syntax
                  ptr = &a[3];                // Compliant: address of array element
                  ptr++;                      // Compliant: increment operator allowed
              }

      - title: "Rule 18.5. Declarations should contain no more than two levels of pointer nesting"
        description: |
          Pointer declarations shall not exceed two levels of pointer nesting.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Limiting pointer nesting levels improves code readability and reduces the complexity that can impair understanding of code behavior.
        code_examples:
          # C examples
          - non_compliant: |
              typedef int8_t *INTPTR;
              
              void function(int8_t **arrPar[]) { // Non-compliant: three levels
                  int8_t ***obj3;            // Non-compliant: three levels
                  INTPTR * const * const obj5; // Non-compliant: three levels
              }
              
              struct s {
                  int8_t ***s3;               // Non-compliant: three levels
              };

          - compliant: |
              typedef int8_t *INTPTR;
              
              void function(void) {
                  int8_t **obj2;              // Compliant: two levels
                  INTPTR *obj4;               // Compliant: two levels
                  int8_t **arr[10];           // Compliant: array of pointers
              }
              
              struct s {
                  int8_t *s1;                 // Compliant: one level
                  int8_t **s2;                // Compliant: two levels
              };

      - title: "Rule 18.6. The address of an object with automatic or thread-local storage shall not be copied to another object that persists after the first object has ceased to exist"
        description: |
          Addresses of automatic or thread-local objects shall not be stored in objects with longer lifetimes.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Preventing storage of addresses beyond object lifetime eliminates undefined behavior from accessing indeterminate addresses after object destruction.
        code_examples:
          # C examples
          - non_compliant: |
              int8_t *func(void) {
                  int8_t local_auto;
                  return &local_auto;         // Non-compliant: address becomes indeterminate
              }
              
              uint16_t *sp;
              void g(uint16_t *p) {
                  sp = p;                     // Non-compliant: if p points to automatic storage
              }
              
              void f(uint16_t u) {
                  g(&u);                      // Non-compliant: address of automatic variable
              }

          - compliant: |
              static int8_t static_var;
              int8_t *func(void) {
                  return &static_var;         // Compliant: static storage duration
              }
              
              uint16_t *sp;
              void g(uint16_t *p) {
                  // Only call with addresses of static/global objects
                  sp = p;                     // Compliant: if p points to static storage
              }
              
              static uint16_t global_u;
              void f(void) {
                  g(&global_u);               // Compliant: address of static variable
              }

      - title: "Rule 18.7. Flexible array members shall not be declared"
        description: |
          Flexible array members shall not be declared in structures.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding flexible array members prevents unexpected sizeof behavior and eliminates dependencies on dynamic memory allocation which is separately banned.
        code_examples:
          # C examples
          - non_compliant: |
              struct s {
                  uint16_t len;
                  uint32_t data[];            // Non-compliant: flexible array member
              };
              
              struct s *copy(struct s *s1) {
                  struct s *s2 = malloc(sizeof(struct s) + (s1->len * sizeof(uint32_t)));
                  *s2 = *s1;                  // Only copies s1->len, not data array
                  return s2;
              }

          - compliant: |
              #define MAX_DATA_SIZE 100
              struct s {
                  uint16_t len;
                  uint32_t data[MAX_DATA_SIZE]; // Compliant: fixed-size array
              };
              
              void copy(struct s *dest, const struct s *src) {
                  *dest = *src;               // Compliant: copies entire structure
              }

      - title: "Rule 18.8. Variable-length arrays shall not be used"
        description: |
          Variable-length arrays shall not be declared.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding variable-length arrays ensures deterministic stack usage and prevents undefined behavior from negative or zero array sizes.
        code_examples:
          # C examples
          - non_compliant: |
              void f(int16_t n) {
                  uint16_t vla[n];            // Non-compliant: variable-length array
                  // Undefined behavior if n <= 0
              }
              
              void g(void) {
                  f(0);                       // Undefined behavior
                  f(-1);                      // Undefined behavior
              }

          - compliant: |
              #define MAX_SIZE 100
              void f(int16_t n) {
                  uint16_t fixed_array[MAX_SIZE]; // Compliant: fixed-size array
                  if (n > 0 && n <= MAX_SIZE) {
                      // Use first n elements safely
                  }
              }

      - title: "Rule 18.9. An object with temporary lifetime shall not undergo array-to-pointer conversion"
        description: |
          Arrays that are members of temporary objects shall not be converted to pointers, except for immediate subscript access.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Preventing array-to-pointer conversion of temporary objects avoids undefined behavior from accessing arrays after their lifetime ends.
        code_examples:
          # C examples
          - non_compliant: |
              struct S1 {
                  int32_t array[10];
              };
              
              struct S1 getS1(void);
              
              void foo(void) {
                  int32_t *p = getS1().array; // Non-compliant: creates dangling pointer
                  foo_func(getS1().array);    // Non-compliant: temporary array-to-pointer
              }

          - compliant: |
              struct S1 {
                  int32_t array[10];
              };
              
              struct S1 getS1(void);
              struct S1 s1;
              
              void foo(void) {
                  int32_t *p = s1.array;      // Compliant: not temporary
                  int32_t j = getS1().array[3]; // Compliant: immediate access
                  s1 = getS1();               // Compliant: assign to named object
                  p = s1.array;               // Compliant: use named object
              }

      - title: "Rule 18.10. Pointers to variably-modified array types shall not be used"
        description: |
          Pointers to variably-modified array types shall not be declared as compatibility between such types cannot be determined at compile-time.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding pointers to variably-modified arrays prevents undefined behavior from incompatible array type assignments that cannot be verified at compile-time.
        code_examples:
          # C examples
          - non_compliant: |
              void f1(uint16_t n, uint16_t (*a)[n]) { // Non-compliant: pointer to VLA
                  uint16_t (*p)[20];
                  p = a;                      // Undefined unless n == 20
              }

          - compliant: |
              void f2(uint16_t n, uint16_t a[n]) { // Compliant: array parameter (becomes pointer)
                  uint16_t *p;
                  p = a;                      // Compliant: well-defined pointer assignment
              }
              
              #define FIXED_SIZE 20
              void f3(uint16_t (*a)[FIXED_SIZE]) { // Compliant: fixed-size array pointer
                  uint16_t (*p)[FIXED_SIZE];
                  p = a;                      // Compliant: compatible types
              }

  - name: "5.19. Overlapping storage"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 19.1. An object shall not be assigned or copied to an overlapping object"
        description: |
          Objects shall not be assigned or copied to other objects that overlap in memory.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Preventing overlapping assignments eliminates undefined behavior that occurs when memory regions overlap during copy or assignment operations.
        code_examples:
          # C examples
          - non_compliant: |
              #include <string.h>
              
              void fn(void) {
                  union {
                      int16_t i;
                      int32_t j;
                  } a = {0};
                  
                  a.j = a.i;                  // Non-compliant: overlapping assignment
              }
              
              void f(void) {
                  int16_t a[20];
                  memcpy(&a[5], &a[4], 2u * sizeof(a[0])); // Non-compliant: overlapping copy
              }

          - compliant: |
              #include <string.h>
              
              void g(void) {
                  int16_t a[20];
                  int16_t *p = &a[0];
                  int16_t *q = &a[0];
                  *p = *q;                    // Compliant: exact overlap with compatible types
                  
                  memmove(&a[5], &a[4], 2u * sizeof(a[0])); // Compliant: memmove handles overlap
              }

      - title: "Rule 19.2. The union keyword should not be used"
        description: |
          Union types should be avoided.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding unions prevents unspecified values, implementation-defined behavior, and reduces dependencies on platform-specific memory layout details.
        code_examples:
          # C examples
          - non_compliant: |
              uint32_t zext(uint16_t s) {
                  union {                     // Non-compliant: union usage
                      uint32_t ul;
                      uint16_t us;
                  } tmp;
                  tmp.us = s;
                  return tmp.ul;              // Unspecified value returned
              }

          - compliant: |
              uint32_t zext(uint16_t s) {     // Compliant: explicit conversion
                  return (uint32_t)s;         // Well-defined zero extension
              }
              
              typedef struct {                // Compliant: use struct instead
                  uint16_t us;
                  uint16_t padding;
              } conversion_t;

      - title: "Rule 19.3. A union member shall not be read unless it has been previously set"
        description: |
          Union members shall only be read after they have been previously set, and no assignment to a different member has occurred since.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Ensuring union members are properly set before reading prevents undefined or implementation-defined behavior from accessing uninitialized or stale data.
        code_examples:
          # C examples
          - non_compliant: |
              uint32_t floatrep(float flt) {
                  union {
                      float flt;
                      uint32_t bits;
                  } tmp;
                  tmp.flt = flt;
                  return tmp.bits;            // Non-compliant: read different member
              }
              
              uint32_t zerobits(uint32_t x) {
                  union {
                      uint32_t x;
                      uint16_t lo;
                  } tmp;
                  tmp.x = x;
                  tmp.lo = 0;
                  return tmp.x;               // Non-compliant: x not written most recently
              }

          - compliant: |
              uint8_t floatbytes(float flt) {
                  union {
                      float flt;
                      uint8_t bytes[sizeof(float)];
                  } tmp;
                  tmp.flt = flt;
                  return tmp.bytes[1];        // Compliant: character array exception
              }
              
              uint32_t process_value(uint32_t x) {
                  union {
                      uint32_t value;
                  } tmp;
                  tmp.value = x;
                  return tmp.value;           // Compliant: same member read as written
              }

  - name: "5.20. Preprocessing directives"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 20.1. #include directives should only be preceded by preprocessor directives or comments"
        description: |
          Include directives should be grouped together near the top of files and only preceded by preprocessor directives or comments.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Grouping includes at the top improves code readability and prevents undefined behavior from including standard headers within declarations or before related usage.
        code_examples:
          # C examples
          - non_compliant: |
              /* f.c */
              int16_t var;
              #include "f.h"                  // Non-compliant: include after declaration
              
              int32_t i = 0;
              #include "f3.h"                 // Non-compliant: include after definition

          - compliant: |
              /* f1.c */
              #define F1_MACRO                // Compliant: preprocessor directive before include
              #include "f1.h"                 // Compliant: grouped at top
              #include "f2.h"                 // Compliant: grouped at top
              
              int32_t i = 0;                  // Compliant: declarations after includes

      - title: "Rule 20.2. The ', \" or \\ characters and the /* or // character sequences shall not occur in a header file name"
        description: |
          Header file names shall not contain quote, backslash, or comment sequence characters.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding problematic characters in header names prevents undefined behavior during preprocessing and ensures portability across implementations.
        code_examples:
          # C examples
          - non_compliant: |
              #include "fi'le.h"              // Non-compliant: single quote in filename
              #include "path\\file.h"         // Non-compliant: backslash in filename  
              #include "file/*comment*/.h"    // Non-compliant: comment sequence in filename

          - compliant: |
              #include "file.h"               // Compliant: no problematic characters
              #include "path/file.h"          // Compliant: forward slash allowed
              #include <standard_header.h>    // Compliant: standard form

      - title: "Rule 20.3. The #include directive shall be followed by either a <filename> or \"filename\" sequence"
        description: |
          Include directives shall use proper syntax with angle brackets or quotes around filenames after macro replacement.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using proper include syntax prevents undefined behavior and ensures consistent, predictable preprocessor behavior across implementations.
        code_examples:
          # C examples
          - non_compliant: |
              #include another.h              // Non-compliant: missing quotes/brackets
              
              #define FILENAME file2.h
              #include FILENAME               // Non-compliant: expands to unquoted name
              
              #define BASE "base"
              #define EXT ".ext"
              #include BASE EXT               // Non-compliant: multiple tokens

          - compliant: |
              #include "filename.h"           // Compliant: quoted filename
              #include <filename.h>           // Compliant: angle brackets
              
              #define HEADER "filename.h"
              #include HEADER                 // Compliant: expands to quoted string
              
              #include "./include/cpu.h"      // Compliant: path in filename

      - title: "Rule 20.4. A macro shall not be defined with the same name as a keyword"
        description: |
          Macros shall not be defined using the same names as language keywords.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding keyword redefinition prevents confusion, maintains language semantics, and eliminates undefined behavior when standard headers are included.
        code_examples:
          # C examples
          - non_compliant: |
              #define int some_other_type     // Non-compliant: redefining keyword
              #include <stdlib.h>             // Undefined behavior with redefined int
              
              #define while(E) for(;(E);)     // Non-compliant: redefining while keyword

          - compliant: |
              #define unless(E) if(!(E))      // Compliant: new identifier
              #define seq(S1,S2) do{S1;S2;}while(false) // Compliant: new identifier
              #define compound(S) {S;}        // Compliant: new identifier
              
              /* C90 only: */
              #define inline                  // Compliant: inline not keyword in C90

      - title: "Rule 20.5. #undef should not be used"
        description: |
          The #undef directive should be avoided as it can make it unclear which macros exist at any point in the translation unit.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding #undef improves code clarity by maintaining consistent macro definitions throughout the translation unit, reducing confusion about macro availability.
        code_examples:
          # C examples
          - non_compliant: |
              #define QUALIFIER volatile
              #undef QUALIFIER                // Non-compliant: undef usage
              
              void f(QUALIFIER int32_t p) {   // Unclear if QUALIFIER is defined
                  while (p != 0) {
                      ; /* Wait... */
                  }
              }

          - compliant: |
              #define QUALIFIER volatile      // Compliant: consistent definition
              
              void f(QUALIFIER int32_t p) {   // Compliant: QUALIFIER clearly defined
                  while (p != 0) {
                      ; /* Wait... */
                  }
              }

      - title: "Rule 20.6. Tokens that look like a preprocessing directive shall not occur within a macro argument"
        description: |
          Macro arguments shall not contain token sequences that look like preprocessing directives.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding directive-like tokens in macro arguments prevents undefined behavior and ensures predictable macro expansion across different implementations.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdio.h>
              #define M(A) printf(#A)
              
              void main(void) {
                  M(
              #ifdef SW                       // Non-compliant: directive in macro arg
                      "Message 1"
              #else                           // Non-compliant: directive in macro arg
                      "Message 2"
              #endif                          // Non-compliant: directive in macro arg
                  );
              }

          - compliant: |
              #include <stdio.h>
              #define M(A) printf(#A)
              
              void main(void) {
              #ifdef SW                       // Compliant: directives outside macro
                  M("Message 1");
              #else
                  M("Message 2");
              #endif
              }

      - title: "Rule 20.7. Expressions resulting from the expansion of macro parameters shall be appropriately delimited"
        description: |
          Macro parameters that expand to expressions shall be delimited with parentheses, brackets, braces, or commas.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Proper delimiting prevents unexpected results from operator precedence when macro substitution occurs, ensuring expressions evaluate as intended.
        code_examples:
          # C examples
          - non_compliant: |
              #define M1(x, y) (x * y)
              
              void func(void) {
                  int r = M1(1 + 2, 3 + 4);   // Non-compliant: expands to (1 + 2 * 3 + 4) = 11
              }

          - compliant: |
              #define M2(x, y) ((x) * (y))    // Compliant: parameters delimited
              
              void func(void) {
                  int r1 = M2(1 + 2, 3 + 4); // Compliant: expands to ((1 + 2) * (3 + 4)) = 21
              }

      - title: "Rule 20.8. The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1"
        description: |
          Controlling expressions in #if and #elif directives shall evaluate to Boolean values (0 or 1).
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Boolean controlling expressions ensure strong typing in conditional compilation and make the intent of preprocessing conditions clear and unambiguous.
        code_examples:
          # C examples
          - non_compliant: |
              #if 10                          // Non-compliant: not Boolean
              #endif
              
              #define VALUE 5
              #if VALUE                       // Non-compliant: not Boolean

          - compliant: |
              #define FALSE 0
              #define TRUE 1
              
              #if FALSE                       // Compliant: Boolean value
              #endif
              
              #if !defined(X)                 // Compliant: evaluates to 0 or 1
              #endif
              
              #if A > B                       // Compliant: comparison evaluates to 0 or 1
              #endif

      - title: "Rule 20.9. All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define'd before evaluation"
        description: |
          All identifiers in #if and #elif expressions shall be defined before use.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Ensuring identifiers are defined prevents the preprocessor from assuming undefined identifiers have value zero, which may not meet developer expectations.
        code_examples:
          # C examples
          - non_compliant: |
              #if M == 0                      // Non-compliant: M might be undefined
                  // Does M expand to zero or is it undefined?
              #endif

          - compliant: |
              #if defined(M)                  // Compliant: M is not evaluated
              #if M == 0                      // Compliant: M is known to be defined
                  // M must expand to zero
              #endif
              #endif
              
              #if defined(B) && (B == 0)      // Compliant: B only evaluated if defined
              #endif

      - title: "Rule 20.10. The # and ## preprocessor operators should not be used"
        description: |
          The stringizing (#) and token-pasting (##) preprocessor operators should be avoided.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding these operators prevents unspecified behavior from evaluation order and improves code clarity by eliminating obscure token manipulations.
        code_examples:
          # C examples
          - non_compliant: |
              #define STRINGIFY(x) #x         // Non-compliant: # operator usage
              #define CONCAT(a, b) a ## b     // Non-compliant: ## operator usage
              
              void func(void) {
                  char *str = STRINGIFY(value);
                  int var = CONCAT(pre, fix);
              }

          - compliant: |
              #define MAX_SIZE 100            // Compliant: simple macro
              
              void func(void) {
                  char str[] = "value";       // Compliant: explicit string
                  int prefix_var = 42;       // Compliant: explicit identifier
              }

      - title: "Rule 20.11. A macro parameter immediately following a # operator shall not immediately be followed by a ## operator"
        description: |
          Macro parameters shall not be used with both # and ## operators in sequence.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Preventing mixed # and ## usage eliminates unspecified behavior and ensures predictable macro expansion results.
        code_examples:
          # C examples
          - non_compliant: |
              #define C(x, y) #x ## y         // Non-compliant: # followed by ##

          - compliant: |
              #define A(x) #x                 // Compliant: only # operator
              #define B(x, y) x ## y          // Compliant: only ## operator
              #define D(x, y) #x, y ## _suffix // Compliant: separate usage

      - title: "Rule 20.12. A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators"
        description: |
          Macro parameters subject to further replacement shall be used consistently either with # and ## operators or in normal expansion, not mixed.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Consistent parameter usage prevents confusion from different expansion behavior when parameters are subject to further macro replacement.
        code_examples:
          # C examples
          - non_compliant: |
              #define AA 0xffff
              #define BB(x) (x) + wow ## x    // Non-compliant: x used both ways
              
              void f(void) {
                  int32_t wowAA = 0;
                  wowAA = BB(AA);             // Expands inconsistently
              }

          - compliant: |
              int32_t speed;
              int32_t speed_scale;
              
              #define SCALE(X) ((X) * X ## _scale) // Compliant: X not subject to replacement
              
              void func(void) {
                  int32_t scaled_speed = SCALE(speed); // Predictable expansion
              }

      - title: "Rule 20.13. A line whose first token is # shall be a valid preprocessing directive"
        description: |
          All lines beginning with # shall form valid preprocessing directives.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Valid preprocessing directives prevent malformed directives from causing incorrect code exclusion and ensure reliable conditional compilation.
        code_examples:
          # C examples
          - non_compliant: |
              #define AAA 2
              
              int32_t foo(void) {
                  int32_t x = 0;
              #ifndef AAA
                  x = 1;
              #else1                          // Non-compliant: invalid directive
                  x = AAA;
              #endif
                  return x;
              }

          - compliant: |
              #define AAA 2
              
              int32_t foo(void) {
                  int32_t x = 0;
              #ifndef AAA
                  x = 1;
              #else                           // Compliant: valid directive
                  x = AAA;
              #endif
                  return x;
              }

      - title: "Rule 20.14. All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related"
        description: |
          Conditional compilation directive pairs (#if/#endif, etc.) shall be contained within the same file.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: multi-file
        severity: mandatory
        impact: |
          Keeping directive pairs in the same file reduces visual complexity and prevents maintenance errors from conditional compilation spanning multiple files.
        code_examples:
          # C examples
          - non_compliant: |
              /* file1.c */
              #if 1                           // Non-compliant: ends in different file
              #include "file1.h"
              /* End of file1.c */
              
              /* file1.h */
              #endif                          // Non-compliant: started in different file
              /* End of file1.h */

          - compliant: |
              /* file1.c */
              #ifdef A                        // Compliant: complete in same file
              #include "file1.h"
              #endif
              /* End of file1.c */
              
              /* file1.h */
              #if 1                           // Compliant: complete in same file
              int x;
              #endif
              /* End of file1.h */

      - title: "Rule 20.15. #define and #undef shall not be used on a reserved identifier or reserved macro name"
        description: |
          Reserved identifiers and macro names (those starting with underscore or defined by the standard) shall not be defined or undefined.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding reserved identifier modification prevents undefined behavior and conflicts with implementation-defined macros and identifiers.
        code_examples:
          # C examples
          - non_compliant: |
              #undef __LINE__                 // Non-compliant: reserved identifier
              #define _GUARD_H 1              // Non-compliant: begins with underscore
              #define defined                 // Non-compliant: reserved identifier
              #define errno my_errno          // Non-compliant: library identifier

          - compliant: |
              #define GUARD_H 1               // Compliant: no leading underscore
              #define NDEBUG                  // Compliant: NDEBUG is allowed
              #define isneg(x) ((x) < 0)      // Compliant: not reserved
              #define MY_ERRNO_VALUE 42       // Compliant: user identifier

  - name: "5.21. Standard libraries"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 21.3. The memory allocation and deallocation functions of <stdlib.h> shall not be used"
        description: |
          Dynamic memory allocation functions (calloc, malloc, realloc, aligned_alloc, free) shall not be used or expanded as macros.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding dynamic memory allocation prevents undefined behavior from improper memory management and eliminates risks associated with memory leaks and use-after-free errors.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdlib.h>
              
              void func(void) {
                  int *ptr = malloc(10 * sizeof(int)); // Non-compliant: malloc usage
                  ptr = realloc(ptr, 20 * sizeof(int)); // Non-compliant: realloc usage
                  free(ptr);                  // Non-compliant: free usage
              }

          - compliant: |
              #define MAX_SIZE 100
              
              void func(void) {
                  static int buffer[MAX_SIZE]; // Compliant: static allocation
                  int local_array[10];        // Compliant: automatic allocation
                  // Use fixed-size arrays instead of dynamic allocation
              }

      - title: "Rule 21.4. The standard header file <setjmp.h> shall not be used"
        description: |
          The setjmp.h header shall not be included and setjmp/longjmp functionality shall not be used.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding setjmp/longjmp prevents undefined behavior from bypassing normal function call mechanisms and maintains predictable control flow.
        code_examples:
          # C examples
          - non_compliant: |
              #include <setjmp.h>             // Non-compliant: including setjmp.h
              
              jmp_buf env;
              
              void func(void) {
                  if (setjmp(env) == 0) {     // Non-compliant: setjmp usage
                      longjmp(env, 1);        // Non-compliant: longjmp usage
                  }
              }

          - compliant: |
              typedef enum {
                  RESULT_OK,
                  RESULT_ERROR
              } result_t;
              
              result_t func(void) {           // Compliant: structured error handling
                  if (error_condition) {
                      return RESULT_ERROR;    // Compliant: normal return
                  }
                  return RESULT_OK;
              }

      - title: "Rule 21.5. The standard header file <signal.h> shall not be used"
        description: |
          The signal.h header shall not be included and signal handling functionality shall not be used.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding signal handling eliminates implementation-defined and undefined behavior associated with asynchronous signal delivery and handling.
        code_examples:
          # C examples
          - non_compliant: |
              #include <signal.h>             // Non-compliant: including signal.h
              
              void handler(int sig) {
                  // Signal handler
              }
              
              void setup(void) {
                  signal(SIGINT, handler);    // Non-compliant: signal usage
              }

          - compliant: |
              void check_condition(void) {    // Compliant: polling approach
                  if (external_flag_set()) {
                      handle_event();         // Compliant: synchronous handling
                  }
              }

      - title: "Rule 21.6. The Standard Library input/output functions shall not be used"
        description: |
          Standard Library I/O functions from stdio.h and wchar.h shall not be used or expanded as macros.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding standard I/O functions eliminates unspecified, undefined, and implementation-defined behaviors associated with streams and file operations.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdio.h>
              
              void func(void) {
                  printf("Hello\n");          // Non-compliant: printf usage
                  FILE *fp = fopen("file", "r"); // Non-compliant: fopen usage
                  fclose(fp);                 // Non-compliant: fclose usage
              }

          - compliant: |
              // Custom I/O functions for embedded systems
              void debug_output(const char *msg) { // Compliant: custom function
                  // Platform-specific output implementation
                  write_to_debug_port(msg);
              }

      - title: "Rule 21.7. The Standard Library functions atof, atoi, atol and atoll of <stdlib.h> shall not be used"
        description: |
          String conversion functions (atof, atoi, atol, atoll) shall not be used or expanded as macros.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding these conversion functions prevents undefined behavior when strings cannot be converted and ensures proper error handling in string-to-number conversions.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdlib.h>
              
              void func(void) {
                  char str[] = "123abc";
                  int val = atoi(str);        // Non-compliant: atoi usage
                  long lval = atol(str);      // Non-compliant: atol usage
                  double dval = atof(str);    // Non-compliant: atof usage
              }

          - compliant: |
              #include <stdlib.h>
              
              void func(void) {
                  char str[] = "123";
                  char *endptr;
                  long val = strtol(str, &endptr, 10); // Compliant: strtol with error checking
                  if (*endptr == '\0') {      // Compliant: check for successful conversion
                      // Use val safely
                  }
              }

      - title: "Rule 21.8. The Standard Library termination functions of <stdlib.h> shall not be used"
        description: |
          Standard Library termination functions (abort, exit, _Exit, quick_exit) shall not be used or expanded as macros.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding termination functions prevents undefined and implementation-defined behaviors associated with abnormal program termination.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdlib.h>
              #include <assert.h>
              #undef NDEBUG
              
              void error_handler(void) {
                  abort();                    // Non-compliant: abort usage
                  exit(1);                    // Non-compliant: exit usage
              }
              
              void func(void) {
                  assert(0);                  // Non-compliant: assert expands to abort()
              }

          - compliant: |
              typedef enum {
                  ERROR_NONE,
                  ERROR_INVALID_INPUT
              } error_code_t;
              
              error_code_t error_handler(void) { // Compliant: structured error handling
                  return ERROR_INVALID_INPUT; // Compliant: return error code
              }
              
              #define NDEBUG                  // Compliant: NDEBUG defined
              #include <assert.h>
              void func(void) {
                  assert(0);                  // Compliant: expands to ((void)0)
              }

      - title: "Rule 21.9. The Standard Library functions bsearch and qsort of <stdlib.h> shall not be used"
        description: |
          Standard Library search and sort functions (bsearch, qsort) shall not be used or expanded as macros.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding these functions prevents undefined behavior from inconsistent comparison functions and eliminates unpredictable stack usage from recursive implementations.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdlib.h>
              
              int compare(const void *a, const void *b) {
                  return (*(int*)a - *(int*)b);
              }
              
              void func(void) {
                  int arr[10] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3};
                  int key = 5;
                  
                  qsort(arr, 10, sizeof(int), compare); // Non-compliant: qsort usage
                  int *result = bsearch(&key, arr, 10, sizeof(int), compare); // Non-compliant: bsearch usage
              }

          - compliant: |
              // Custom sorting implementation with known stack usage
              void bubble_sort(int arr[], int n) { // Compliant: deterministic algorithm
                  for (int i = 0; i < n - 1; i++) {
                      for (int j = 0; j < n - i - 1; j++) {
                          if (arr[j] > arr[j + 1]) {
                              int temp = arr[j];
                              arr[j] = arr[j + 1];
                              arr[j + 1] = temp;
                          }
                      }
                  }
              }

      - title: "Rule 21.10. The Standard Library time and date functions shall not be used"
        description: |
          Standard Library time and date functions from time.h and wcsftime from wchar.h shall not be used.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding time and date functions eliminates unspecified, undefined, and implementation-defined behaviors associated with time representation and conversion.
        code_examples:
          # C examples
          - non_compliant: |
              #include <time.h>               // Non-compliant: including time.h
              
              void func(void) {
                  time_t current_time;
                  current_time = time(NULL);  // Non-compliant: time usage
                  
                  struct tm *timeinfo = localtime(&current_time); // Non-compliant: localtime usage
                  char buffer[80];
                  strftime(buffer, 80, "%Y-%m-%d", timeinfo); // Non-compliant: strftime usage
              }

          - compliant: |
              // Custom time representation for embedded systems
              typedef struct {
                  uint16_t year;
                  uint8_t month;
                  uint8_t day;
                  uint8_t hour;
                  uint8_t minute;
                  uint8_t second;
              } custom_time_t;
              
              void get_system_time(custom_time_t *time) { // Compliant: custom implementation
                  // Platform-specific time retrieval
              }

      - title: "Rule 21.11. The standard header file <tgmath.h> should not be used"
        description: |
          The tgmath.h header should not be included.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding tgmath.h prevents undefined behavior and ensures explicit type-specific function calls for mathematical operations.
        code_examples:
          # C examples
          - non_compliant: |
              #include <tgmath.h>             // Non-compliant: including tgmath.h
              
              void func(void) {
                  float f1, f2;
                  f1 = sqrt(f2);              // Non-compliant: generic sqrt used
              }

          - compliant: |
              #include <math.h>               // Compliant: specific math header
              
              void func(void) {
                  float f1, f2;
                  double d1, d2;
                  
                  f1 = sqrtf(f2);             // Compliant: float-specific function
                  d1 = sqrt(d2);              // Compliant: double-specific function
              }

      - title: "Rule 21.12. The standard header file <fenv.h> shall not be used"
        description: |
          The fenv.h header shall not be included and floating-point environment functions shall not be used.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding floating-point environment control prevents undefined behavior from invalid arguments and unspecified floating-point status flag behavior.
        code_examples:
          # C examples
          - non_compliant: |
              #include <fenv.h>               // Non-compliant: including fenv.h
              
              void func(float x, float y) {
                  float z;
                  feclearexcept(FE_DIVBYZERO); // Non-compliant: fenv function usage
                  z = x / y;
                  if (fetestexcept(FE_DIVBYZERO)) { // Non-compliant: fenv function usage
                      // Handle division by zero
                  }
              }

          - compliant: |
              void func(float x, float y) {   // Compliant: explicit checking
                  float z;
                  if (y != 0.0f) {            // Compliant: explicit zero check
                      z = x / y;
                  } else {
                      // Handle division by zero explicitly
                      z = 0.0f;
                  }
              }

      - title: "Rule 21.13. Any value passed to a function in <ctype.h> shall be representable as an unsigned char or be the value EOF"
        description: |
          Arguments to ctype.h functions shall only be values representable as unsigned char or the EOF value.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Ensuring valid arguments to character classification functions prevents undefined behavior from out-of-range values.
        code_examples:
          # C examples
          - non_compliant: |
              #include <ctype.h>
              
              bool_t func(void) {
                  int value = 256;
                  return isalpha(value);          // Non-compliant: out of range value
              }

          - compliant: |
              #include <ctype.h>
              
              bool_t func(uint8_t a) {
                  return (isdigit((int32_t)a)     // Compliant: unsigned char range
                      && isalpha((int32_t)'b')    // Compliant: valid character
                      && islower(EOF));           // Compliant: EOF value
              }

      - title: "Rule 21.14. The Standard Library function memcmp shall not be used to compare null terminated strings"
        description: |
          The memcmp function shall not be used to compare null terminated strings.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Avoiding memcmp for string comparison prevents false negatives from uninitialized data beyond null terminators affecting comparison results.
        code_examples:
          # C examples
          - non_compliant: |
              #include <string.h>
              
              void func(void) {
                  char buffer1[12];
                  char buffer2[12];
                  
                  strcpy(buffer1, "abc");
                  strcpy(buffer2, "abc");
                  
                  if (memcmp(buffer1, buffer2, sizeof(buffer1)) != 0) { // Non-compliant: string comparison
                      // May report different due to uninitialized data after null
                  }
              }

          - compliant: |
              #include <string.h>
              
              void func(void) {
                  char buffer1[12];
                  char buffer2[12];
                  unsigned char headerStart[6] = {'h', 'e', 'a', 'd', 0, 164};
                  unsigned char packet[6];
                  
                  strcpy(buffer1, "abc");
                  strcpy(buffer2, "abc");
                  
                  if (strcmp(buffer1, buffer2) != 0) { // Compliant: proper string comparison
                      // Compares only up to null terminator
                  }
                  
                  if (memcmp(packet, headerStart, 6) == 0) { // Compliant: non-string data
                      // Valid for fixed-length binary data
                  }
              }

      - title: "Rule 21.15. The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types"
        description: |
          Pointer arguments to memcpy, memmove, and memcmp shall be pointers to compatible types.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Ensuring compatible pointer types prevents unintended partial copying or comparison that may indicate programming errors.
        code_examples:
          # C examples
          - non_compliant: |
              #include <string.h>
              
              void func(uint8_t s1[8], uint16_t s2[8]) {
                  memcpy(s1, s2, 8);          // Non-compliant: incompatible types
                  // Only copies part of s2 elements
              }

          - compliant: |
              #include <string.h>
              
              void func(uint8_t s1[8], uint8_t s2[8]) {
                  memcpy(s1, s2, 8);          // Compliant: compatible types
              }
              
              void func2(uint16_t s1[4], uint16_t s2[4]) {
                  memcpy(s1, s2, 4 * sizeof(uint16_t)); // Compliant: compatible types
              }

      - title: "Rule 21.16. The pointer arguments to the Standard Library function memcmp shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type"
        description: |
          Arguments to memcmp shall point to pointer, signed, unsigned, Boolean, or enum types, not to structures, unions, floating-point, or character arrays.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Restricting memcmp usage prevents incorrect comparisons due to padding in structures, representation differences in floating-point, or string termination issues.
        code_examples:
          # C examples
          - non_compliant: |
              #include <string.h>
              
              struct S { int a; char b; };
              union U { uint32_t range; uint32_t height; };
              
              bool_t func(void) {
                  struct S s1, s2;
                  union U u1, u2;
                  const char a[6] = "task";
                  const char b[6] = "task";
                  
                  return (memcmp(&s1, &s2, sizeof(struct S)) != 0)    // Non-compliant: struct
                      || (memcmp(&u1, &u2, sizeof(union U)) != 0)     // Non-compliant: union
                      || (memcmp(a, b, 6) != 0);                      // Non-compliant: char array
              }

          - compliant: |
              #include <string.h>
              
              bool_t func(void) {
                  uint32_t arr1[4] = {1, 2, 3, 4};
                  uint32_t arr2[4] = {1, 2, 3, 4};
                  int *ptr1, *ptr2;
                  
                  return (memcmp(arr1, arr2, sizeof(arr1)) != 0)      // Compliant: unsigned type
                      || (memcmp(&ptr1, &ptr2, sizeof(ptr1)) != 0);   // Compliant: pointer type
              }

      - title: "Rule 21.17. Use of the string handling functions from <string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters"
        description: |
          String handling functions shall not access memory beyond the bounds of the objects passed as parameters.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Preventing buffer overruns eliminates undefined behavior from accessing memory beyond object boundaries in string operations.
        code_examples:
          # C examples
          - non_compliant: |
              #include <string.h>
              
              void func(const char *str) {
                  char string[6] = "Short";
                  char text[5] = "Token";         // No null terminator
                  
                  strcpy(string, "Too long to fit"); // Non-compliant: buffer overflow
                  size_t len = strlen(text);      // Non-compliant: no null terminator
              }

          - compliant: |
              #include <string.h>
              
              void func(const char *str) {
                  char string[20] = "Short";
                  char text[6] = "Token";         // Proper null termination
                  
                  if (strlen(str) < (sizeof(string) - 1u)) {
                      strcpy(string, str);        // Compliant: bounds checked
                  }
                  size_t len = strlen(text);      // Compliant: properly terminated
              }

      - title: "Rule 21.18. The size_t argument passed to any function in <string.h> shall have an appropriate value"
        description: |
          The size_t argument to string.h functions shall be positive and not exceed the size of the smallest object passed through pointer parameters.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Ensuring appropriate size arguments prevents undefined behavior from accessing memory beyond object boundaries in string operations.
        code_examples:
          # C examples
          - non_compliant: |
              #include <string.h>
              
              void func(void) {
                  char buf1[5] = "12345";
                  char buf2[10] = "1234567890";
                  
                  if (memcmp(buf1, buf2, 6) == 0) {   // Non-compliant: exceeds buf1 size
                      // Process
                  }
                  
                  memcpy(buf1, buf2, 10);             // Non-compliant: exceeds buf1 size
              }

          - compliant: |
              #include <string.h>
              
              void func(void) {
                  char buf1[5] = "12345";
                  char buf2[10] = "1234567890";
                  
                  if (memcmp(buf1, buf2, 5) == 0) {   // Compliant: within buf1 size
                      // Process
                  }
                  
                  memcpy(buf1, buf2, sizeof(buf1));   // Compliant: exact buf1 size
              }

      - title: "Rule 21.19. The pointers returned by the Standard Library functions localeconv, getenv, setlocale or strerror shall only be used as if they have pointer to const-qualified type"
        description: |
          Pointers returned by localeconv, getenv, setlocale, and strerror shall be treated as const-qualified.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Treating returned pointers as const prevents undefined behavior from modifying strings or structures owned by the standard library.
        code_examples:
          # C examples
          - non_compliant: |
              #include <locale.h>
              #include <stdlib.h>
              #include <string.h>
              
              void func(void) {
                  char *s1 = setlocale(LC_ALL, 0);       // Non-compliant: non-const pointer
                  struct lconv *conv = localeconv();     // Non-compliant: non-const pointer
                  char *env = getenv("PATH");             // Non-compliant: non-const pointer
                  
                  s1[1] = 'A';                            // Undefined behavior
                  conv->decimal_point = "^";              // Undefined behavior
              }

          - compliant: |
              #include <locale.h>
              #include <stdlib.h>
              #include <string.h>
              
              void func(void) {
                  char str[128];
                  strcpy(str, setlocale(LC_ALL, 0));      // Compliant: immediate copy
                  
                  const struct lconv *conv = localeconv(); // Compliant: const pointer
                  const char *env = getenv("PATH");       // Compliant: const pointer
                  
                  // Use values through const pointers only
              }

      - title: "Rule 21.20. The pointer returned by the Standard Library functions asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or strerror shall not be used following a subsequent call to the same function"
        description: |
          Pointers returned by asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale, or strerror shall not be used after subsequent calls to the same function.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Preventing pointer reuse after subsequent calls eliminates undefined behavior from accessing modified static buffers owned by the standard library.
        code_examples:
          # C examples
          - non_compliant: |
              #include <locale.h>
              #include <stdio.h>
              #include <string.h>
              
              void func(void) {
                  const char *res1;
                  const char *res2;
                  
                  res1 = setlocale(LC_ALL, 0);
                  res2 = setlocale(LC_MONETARY, "French"); // Invalidates res1
                  printf("%s\n", res1);       // Non-compliant: use after subsequent call
              }

          - compliant: |
              #include <locale.h>
              #include <stdio.h>
              #include <string.h>
              
              void func(void) {
                  const char *res1;
                  const char *res2;
                  char copy[128];
                  
                  res1 = setlocale(LC_ALL, 0);
                  strcpy(copy, res1);         // Compliant: copy made before subsequent call
                  res2 = setlocale(LC_MONETARY, "French");
                  printf("%s\n", copy);       // Compliant: using copy
                  printf("%s\n", res2);       // Compliant: no subsequent call before use
              }

      - title: "Rule 21.21. The Standard Library function system of <stdlib.h> shall not be used"
        description: |
          The system function shall not be used or expanded as a macro.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding the system function prevents undefined behavior and eliminates common security vulnerabilities from command injection attacks.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdlib.h>
              
              void func(void) {
                  int result = system("ls -l"); // Non-compliant: system usage
                  system("rm tempfile");        // Non-compliant: system usage
              }

          - compliant: |
              // Custom platform-specific implementations
              int execute_list_command(void) { // Compliant: custom implementation
                  // Platform-specific directory listing
                  return 0;
              }
              
              int remove_temp_file(const char *filename) { // Compliant: specific function
                  // Platform-specific file removal
                  return 0;
              }

      - title: "Rule 21.22. All operand arguments to any type-generic macros declared in <tgmath.h> shall have an appropriate essential type"
        description: |
          Operand arguments to tgmath.h macros shall have essentially signed, unsigned, or floating types, with restrictions on complex floating types for certain macros.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Ensuring appropriate operand types prevents undefined behavior from non-arithmetic type arguments to type-generic mathematical functions.
        code_examples:
          # C examples
          - non_compliant: |
              #include <tgmath.h>             // Non-compliant with Rule 21.11
              
              void func(void) {
                  char c1, c2;
                  void *p1, *p2;
                  _Complex float cf1, cf2;
                  
                  c2 = sqrt(c1);              // Non-compliant: essentially character
                  p2 = sqrt(p1);              // Non-compliant: pointer type
                  cf2 = ceil(cf1);            // Non-compliant: complex to real-only function
              }

          - compliant: |
              #include <math.h>               // Compliant: specific header
              
              void func(void) {
                  float f1, f2;
                  int32_t i1, i2;
                  _Complex float cf1, cf2;
                  
                  f2 = sqrtf(f1);             // Compliant: appropriate type
                  i2 = (int32_t)sqrtf((float)i1); // Compliant: explicit conversion
                  cf2 = csqrtf(cf1);          // Compliant: complex-specific function
              }

      - title: "Rule 21.23. All operand arguments to any multi-argument type-generic macros declared in <tgmath.h> shall have the same standard type"
        description: |
          All operand arguments to multi-argument tgmath.h macros shall have the same standard type after integer promotion.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Ensuring consistent argument types prevents ambiguous type deduction and potential precision loss in type-generic mathematical operations.
        code_examples:
          # C examples
          - non_compliant: |
              #include <tgmath.h>             // Non-compliant with Rule 21.11
              
              void func(void) {
                  float f1, f2;
                  double d1, d2;
                  int i32;
                  long l32;
                  
                  f2 = pow(f1, d2);           // Non-compliant: mixed float/double
                  i32 = pow(i32, l32);        // Non-compliant: different types after promotion
                  i32 = pow(10u, 110ul);      // Non-compliant: unsigned int vs unsigned long
              }

          - compliant: |
              #include <math.h>               // Compliant: specific header
              
              void func(void) {
                  float f1, f2;
                  double d1, d2;
                  int i32;
                  short s16;
                  
                  f2 = powf(f1, f2);          // Compliant: same types
                  d2 = pow(d1, d2);           // Compliant: same types
                  i32 = (int)powf((float)i32, (float)d2); // Compliant: explicit conversion
                  i32 = (int)powf((float)s16, (float)i32); // Compliant: both promote to int
              }

      - title: "Rule 21.24. The random number generator functions of <stdlib.h> shall not be used"
        description: |
          Random number generator functions (rand, srand) shall not be used.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding standard random functions prevents use of poor-quality, predictable sequences that may compromise security or randomness requirements.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdlib.h>
              
              void func(void) {
                  srand(12345);               // Non-compliant: srand usage
                  int r = rand();             // Non-compliant: rand usage
                  int value = rand() % 100;   // Non-compliant: rand usage
              }

          - compliant: |
              // Custom random number generator with known properties
              static uint32_t random_state = 1;
              
              uint32_t custom_random(void) {  // Compliant: custom implementation
                  random_state = random_state * 1103515245 + 12345;
                  return (random_state / 65536) % 32768;
              }
              
              void seed_random(uint32_t seed) { // Compliant: custom seeding
                  random_state = seed;
              }

      - title: "Rule 21.25. All memory synchronization operations shall be executed in sequentially consistent order"
        description: |
          Memory synchronization operations shall only use memory_order_seq_cst to ensure sequential consistency across all platforms.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using only sequential consistency prevents non-portable behavior and unintuitive memory ordering effects that depend on hardware architecture.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdatomic.h>
              
              void func(void) {
                  _Atomic int atomic_var;
                  int value = 42;
                  
                  atomic_store_explicit(&atomic_var, value, memory_order_relaxed); // Non-compliant: relaxed ordering
                  value = atomic_load_explicit(&atomic_var, memory_order_acquire); // Non-compliant: acquire ordering
                  atomic_thread_fence(memory_order_release); // Non-compliant: release ordering
              }

          - compliant: |
              #include <stdatomic.h>
              
              void func(void) {
                  _Atomic int atomic_var;
                  int value = 42;
                  
                  atomic_store(&atomic_var, value);           // Compliant: implicit seq_cst
                  atomic_store_explicit(&atomic_var, value, memory_order_seq_cst); // Compliant: explicit seq_cst
                  value = atomic_load(&atomic_var);           // Compliant: implicit seq_cst
                  atomic_thread_fence(memory_order_seq_cst);  // Compliant: seq_cst ordering
              }

      - title: "Rule 21.26. The Standard Library function mtx_timedlock() shall only be invoked on mutex objects of appropriate mutex type"
        description: |
          The mtx_timedlock function shall only be called on mutex objects of type mtx_timed or (mtx_timed | mtx_recursive).
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Ensuring appropriate mutex types prevents undefined behavior from attempting timed locks on mutexes that do not support timeout operations.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              void func(void) {
                  mtx_t plain_mutex;
                  mtx_t timed_mutex;
                  struct timespec timeout;
                  
                  mtx_init(&plain_mutex, mtx_plain);
                  mtx_init(&timed_mutex, mtx_timed);
                  
                  mtx_timedlock(&plain_mutex, &timeout); // Non-compliant: plain mutex doesn't support timeout
              }

          - compliant: |
              #include <threads.h>
              
              void func(void) {
                  mtx_t timed_mutex;
                  mtx_t recursive_timed_mutex;
                  struct timespec timeout;
                  
                  mtx_init(&timed_mutex, mtx_timed);
                  mtx_init(&recursive_timed_mutex, mtx_timed | mtx_recursive);
                  
                  mtx_timedlock(&timed_mutex, &timeout);          // Compliant: timed mutex
                  mtx_timedlock(&recursive_timed_mutex, &timeout); // Compliant: timed recursive mutex
              }

  - name: "5.22. Resources"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 22.1a. All dynamically allocated memory shall be explicitly released"
        description: |
          Memory allocated by malloc, calloc, realloc, and aligned_alloc shall be explicitly released using free.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Explicit memory release prevents memory exhaustion and ensures proper cleanup of dynamically allocated memory resources.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdlib.h>
              
              int main(void) {
                  void *b = malloc(40);       // Non-compliant: memory not released
                  char *c = calloc(10, sizeof(char)); // Non-compliant: memory not released
                  return 1;
              }

          - compliant: |
              #include <stdlib.h>
              
              int main(void) {
                  void *b = malloc(40);       // Compliant: will be released
                  if (b != NULL) {
                      // Use memory
                      free(b);                // Compliant: explicit release
                  }
                  
                  char *c = calloc(10, sizeof(char)); // Compliant: will be released
                  if (c != NULL) {
                      // Use memory
                      free(c);                // Compliant: explicit release
                  }
                  return 0;
              }

      - title: "Rule 22.1b. All opened files shall be explicitly closed"
        description: |
          Files opened by fopen shall be explicitly closed using fclose.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Explicit file closure prevents file handle exhaustion and ensures proper cleanup of file resources.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdio.h>
              
              int main(void) {
                  FILE *fp = fopen("tmp", "r"); // Non-compliant: file not closed
                  
                  FILE *fp2 = fopen("tmp-1", "w");
                  fprintf(fp2, "*");
                  fp2 = fopen("tmp-2", "w");  // Non-compliant: tmp-1 handle lost
                  return 1;
              }

          - compliant: |
              #include <stdio.h>
              
              int main(void) {
                  FILE *fp = fopen("tmp", "r"); // Compliant: will be closed
                  if (fp != NULL) {
                      // Use file
                      fclose(fp);             // Compliant: explicit close
                  }
                  
                  FILE *fp2 = fopen("tmp-1", "w");
                  if (fp2 != NULL) {
                      fprintf(fp2, "*");
                      fclose(fp2);            // Compliant: close before reassignment
                  }
                  return 0;
              }

      - title: "Rule 22.2. A block of memory shall only be freed if it was allocated by means of a Standard Library function"
        description: |
          Memory blocks shall only be freed if they were allocated by malloc, calloc, or realloc, and each block shall be freed only once.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Proper memory management prevents undefined behavior from freeing non-allocated memory or double-freeing allocated memory.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdlib.h>
              
              void func(void) {
                  int32_t a;
                  char *p = malloc(512);
                  char *q = p;
                  
                  free(&a);                   // Non-compliant: not allocated storage
                  free(p);                    // First free is OK
                  free(q);                    // Non-compliant: double free
                  p = realloc(p, 1024);       // Non-compliant: may free already freed memory
              }

          - compliant: |
              #include <stdlib.h>
              
              void func(void) {
                  char *p = malloc(512);
                  if (p != NULL) {
                      // Use memory
                      free(p);                // Compliant: allocated memory freed once
                      p = NULL;               // Compliant: prevent accidental reuse
                  }
                  
                  char *q = malloc(1024);
                  if (q != NULL) {
                      char *new_q = realloc(q, 2048); // Compliant: realloc handles old memory
                      if (new_q != NULL) {
                          q = new_q;
                      }
                      free(q);                // Compliant: proper cleanup
                  }
              }

      - title: "Rule 22.3. The same file shall not be open for read and write access at the same time on different streams"
        description: |
          Files shall not be opened simultaneously for both read and write access on different streams due to implementation-defined behavior.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Avoiding simultaneous read/write access prevents implementation-defined behavior and ensures predictable file operations.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdio.h>
              
              void func(void) {
                  FILE *fw = fopen("tmp", "r+"); // Opens for read/write
                  FILE *fr = fopen("tmp", "r");  // Non-compliant: same file open for read
                  
                  // File operations with undefined behavior
                  fclose(fw);
                  fclose(fr);
              }

          - compliant: |
              #include <stdio.h>
              
              void func(void) {
                  FILE *fp1 = fopen("tmp", "r"); // Compliant: read-only
                  FILE *fp2 = fopen("tmp", "r"); // Compliant: multiple read-only OK
                  
                  fclose(fp1);
                  fclose(fp2);
                  
                  FILE *fw = fopen("tmp", "r+"); // Compliant: single stream for read/write
                  // Perform all operations on single stream
                  fclose(fw);
              }

      - title: "Rule 22.4. There shall be no attempt to write to a stream which has been opened as read-only"
        description: |
          Streams opened as read-only shall not be used for write operations as this results in unspecified behavior.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Preventing writes to read-only streams avoids unspecified behavior and ensures proper stream usage according to access mode.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdio.h>
              
              void func(void) {
                  FILE *fp = fopen("tmp", "r"); // Read-only mode
                  if (fp != NULL) {
                      fprintf(fp, "What happens now?"); // Non-compliant: write to read-only
                      fclose(fp);
                  }
              }

          - compliant: |
              #include <stdio.h>
              
              void func(void) {
                  FILE *fp_read = fopen("tmp", "r"); // Compliant: read-only for reading
                  if (fp_read != NULL) {
                      char buffer[100];
                      fgets(buffer, sizeof(buffer), fp_read); // Compliant: reading
                      fclose(fp_read);
                  }
                  
                  FILE *fp_write = fopen("tmp", "w"); // Compliant: write mode for writing
                  if (fp_write != NULL) {
                      fprintf(fp_write, "Writing data"); // Compliant: write to write mode
                      fclose(fp_write);
                  }
              }

      - title: "Rule 22.5. A pointer to a FILE object shall not be dereferenced"
        description: |
          Pointers to FILE objects shall not be dereferenced directly or indirectly as the internal structure is implementation-specific.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Preventing FILE object dereferencing ensures portability and avoids implementation-specific behavior that may not work across different systems.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdio.h>
              #include <string.h>
              
              void func(void) {
                  FILE *pf1 = fopen("file1", "r");
                  FILE *pf2;
                  FILE f3;
                  
                  f3 = *pf2;                  // Non-compliant: dereferencing FILE*
                  memcpy(&f3, pf1, sizeof(FILE)); // Non-compliant: indirect dereferencing
                  
                  // Assuming FILE has a member 'pos'
                  // pf1->pos = 0;            // Non-compliant: accessing internal members
                  
                  if (pf1) fclose(pf1);
              }

          - compliant: |
              #include <stdio.h>
              
              void func(void) {
                  FILE *pf1 = fopen("file1", "r");
                  FILE *pf2;
                  
                  pf2 = pf1;                  // Compliant: pointer assignment
                  
                  if (pf1 != NULL) {
                      // Use FILE* through standard library functions only
                      fgetc(pf1);             // Compliant: using standard functions
                      fclose(pf1);            // Compliant: proper cleanup
                  }
              }

      - title: "Rule 22.6. The value of a pointer to a FILE shall not be used after the associated stream has been closed"
        description: |
          Pointers to FILE objects shall not be used after the associated stream has been closed as the value becomes indeterminate.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using FILE pointers after closing prevents undefined behavior and ensures predictable stream operations according to the C Standard.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdio.h>
              
              void func(void) {
                  FILE *fp = fopen("tmp", "w");
                  if (fp == NULL) {
                      return;
                  }
                  fclose(fp);
                  
                  fprintf(fp, "?");       // Non-compliant: using closed FILE*
                  void *p = fp;           // Non-compliant: using closed FILE* value
              }

          - compliant: |
              #include <stdio.h>
              
              void func(void) {
                  FILE *fp = fopen("tmp", "w");
                  if (fp != NULL) {
                      fprintf(fp, "data");    // Compliant: using open FILE*
                      fclose(fp);
                      fp = NULL;              // Compliant: prevent accidental reuse
                  }
              }

      - title: "Rule 22.7. The macro EOF shall only be compared with the unmodified return value from any Standard Library function capable of returning EOF"
        description: |
          EOF comparisons shall use unmodified return values from standard library functions.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Unmodified EOF comparisons prevent type conversion issues that could make EOF indistinguishable from valid character codes.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdio.h>
              
              void func(void) {
                  char ch = (char)getchar();      // Return value converted
                  
                  if (EOF != (int32_t)ch) {       // Non-compliant: comparing converted value
                      // Process character
                  }
              }

          - compliant: |
              #include <stdio.h>
              
              void func(void) {
                  int i_ch = getchar();           // Compliant: unmodified return value
                  
                  if (EOF != i_ch) {              // Compliant: comparing unmodified value
                      char ch = (char)i_ch;       // Convert after comparison
                  }
                  
                  // Alternative: use feof() after conversion
                  char ch2 = (char)getchar();
                  if (!feof(stdin)) {             // Compliant: using feof() instead
                      // Process character
                  }
              }

      - title: "Rule 22.8. The value of errno shall be set to zero prior to a call to an errno-setting-function"
        description: |
          The errno variable shall be set to zero before calling errno-setting functions.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Setting errno to zero before errno-setting functions ensures that error conditions can be reliably detected after the function call.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdio.h>
              #include <errno.h>
              #include <stdlib.h>
              
              void func(void) {
                  long result = strtol("123", NULL, 10);  // Non-compliant: errno not cleared
                  
                  if (errno != 0) {
                      // Error handling
                  }
              }

          - compliant: |
              #include <stdio.h>
              #include <errno.h>
              #include <stdlib.h>
              
              void func(void) {
                  errno = 0;                              // Compliant: clear errno first
                  long result = strtol("123", NULL, 10);
                  
                  if (errno != 0) {
                      // Error handling
                  }
              }

      - title: "Rule 22.9. The value of errno shall be tested against zero after calling an errno-setting-function"
        description: |
          The errno variable shall be tested for errors after calling errno-setting functions and before any subsequent function calls.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Testing errno after errno-setting functions ensures proper error detection and prevents using potentially invalid return values.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdio.h>
              #include <errno.h>
              #include <stdlib.h>
              
              void func(void) {
                  errno = 0;
                  long result = strtol("123", NULL, 10);
                  
                  printf("Result: %ld\n", result);        // Non-compliant: function call before errno test
                  
                  if (errno != 0) {
                      // Error handling
                  }
              }

          - compliant: |
              #include <stdio.h>
              #include <errno.h>
              #include <stdlib.h>
              
              void func(void) {
                  errno = 0;
                  long result = strtol("123", NULL, 10);
                  
                  if (errno != 0) {                       // Compliant: test errno immediately
                      // Error handling
                  } else {
                      printf("Result: %ld\n", result);    // Compliant: use result after error check
                  }
              }

      - title: "Rule 22.10. The value of errno shall only be tested when the last function to be called was an errno-setting-function"
        description: |
          The errno variable shall only be tested for errors when the most recent function call was an errno-setting function.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Testing errno only after errno-setting functions ensures reliable error detection since other functions may not set errno consistently.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdio.h>
              #include <errno.h>
              #include <stdlib.h>
              
              void func(void) {
                  errno = 0;
                  double dbl = atof("A.12");              // atof may not set errno
                  
                  if (errno == 0) {                       // Non-compliant: testing errno after non-errno-setting function
                      // May have invalid value
                  }
              }

          - compliant: |
              #include <stdio.h>
              #include <errno.h>
              #include <stdlib.h>
              
              void func(void) {
                  errno = 0;
                  double dbl = strtod("A.12", NULL);      // strtod is errno-setting function
                  
                  if (errno == 0) {                       // Compliant: testing errno after errno-setting function
                      // dbl has valid value
                  }
              }

      - title: "Rule 22.11. A thread that was previously either joined or detached shall not be subsequently joined nor detached"
        description: |
          Threads shall not be joined or detached multiple times as this results in undefined behavior.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Preventing multiple join/detach operations on threads avoids undefined behavior and ensures proper thread lifecycle management.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              void func(void) {
                  thrd_t id1, id2;
                  thrd_create(&id1, worker_func, NULL);
                  thrd_create(&id2, worker_func, NULL);
                  
                  thrd_join(id1, NULL);                   // First join is OK
                  thrd_join(id1, NULL);                   // Non-compliant: already joined
                  
                  thrd_detach(id2);                       // First detach is OK
                  thrd_join(id2, NULL);                   // Non-compliant: already detached
              }

          - compliant: |
              #include <threads.h>
              
              void func(void) {
                  thrd_t id1, id2;
                  thrd_create(&id1, worker_func, NULL);
                  thrd_create(&id2, worker_func, NULL);
                  
                  thrd_join(id1, NULL);                   // Compliant: single join
                  thrd_detach(id2);                       // Compliant: single detach
              }

      - title: "Rule 22.12a. Thread objects shall only be accessed by appropriate Standard Library functions"
        description: |
          Thread objects shall exclusively be accessed via thrd_create, thrd_detach, thrd_join, and thrd_equal functions.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Using only appropriate Standard Library functions prevents undefined behavior from direct manipulation of thread objects and ensures proper thread management.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              #include <string.h>
              
              thrd_t id1, id2;
              
              int worker(void *ignore) {
                  if (id1 == id2) {               // Non-compliant: direct comparison
                      return 1;
                  }
                  
                  memcpy(&id2, &id1, sizeof(thrd_t)); // Non-compliant: direct copy
                  return 0;
              }

          - compliant: |
              #include <threads.h>
              
              thrd_t id1, id2;
              
              int worker(void *ignore) {
                  if (thrd_equal(id1, id2)) {     // Compliant: using standard function
                      return 1;
                  }
                  
                  // Create new thread properly
                  thrd_create(&id2, worker, NULL); // Compliant: standard function
                  return 0;
              }

      - title: "Rule 22.12b. Mutex objects shall only be accessed by appropriate Standard Library functions"
        description: |
          Mutex objects shall exclusively be accessed via mtx_destroy, mtx_init, mtx_lock, mtx_trylock, mtx_timedlock, mtx_unlock, cnd_wait, and cnd_timedwait functions.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Using only appropriate Standard Library functions prevents undefined behavior from direct manipulation of mutex objects and ensures proper synchronization.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              #include <string.h>
              
              mtx_t Ra, Rb;
              
              int worker(void *ignore) {
                  Rb = Ra;                        // Non-compliant: direct assignment
                  memcpy(&Rb, &Ra, sizeof(mtx_t)); // Non-compliant: direct copy
                  return 0;
              }

          - compliant: |
              #include <threads.h>
              
              mtx_t Ra, Rb;
              
              int worker(void *ignore) {
                  mtx_init(&Ra, mtx_plain);       // Compliant: standard function
                  mtx_init(&Rb, mtx_plain);       // Compliant: standard function
                  
                  mtx_lock(&Ra);                  // Compliant: standard function
                  mtx_unlock(&Ra);                // Compliant: standard function
                  return 0;
              }

      - title: "Rule 22.12c. Condition variables shall only be accessed by appropriate Standard Library functions"
        description: |
          Condition variables shall exclusively be accessed via cnd_broadcast, cnd_destroy, cnd_init, cnd_signal, cnd_wait, and cnd_timedwait functions.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Using only appropriate Standard Library functions prevents undefined behavior from direct manipulation of condition variables and ensures proper thread synchronization.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              #include <string.h>
              
              cnd_t cond1, cond2;
              
              int worker(void *ignore) {
                  cond2 = cond1;                  // Non-compliant: direct assignment
                  memcmp(&cond1, &cond2, sizeof(cnd_t)); // Non-compliant: direct comparison
                  return 0;
              }

          - compliant: |
              #include <threads.h>
              
              cnd_t cond1, cond2;
              mtx_t mutex;
              
              int worker(void *ignore) {
                  cnd_init(&cond1);               // Compliant: standard function
                  cnd_init(&cond2);               // Compliant: standard function
                  
                  mtx_lock(&mutex);
                  cnd_wait(&cond1, &mutex);       // Compliant: standard function
                  mtx_unlock(&mutex);
                  
                  cnd_signal(&cond2);             // Compliant: standard function
                  return 0;
              }

      - title: "Rule 22.12d. Thread-specific storage pointers shall only be accessed by appropriate Standard Library functions"
        description: |
          Thread-specific storage pointers shall exclusively be accessed by tss_create, tss_delete, tss_get, and tss_set functions.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Using only appropriate Standard Library functions prevents undefined behavior from direct manipulation of thread-specific storage and ensures proper thread-local data management.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              tss_t key1, key2;
              
              int worker(void *ignore) {
                  key1++;                         // Non-compliant: direct manipulation
                  key2 = key1;                    // Non-compliant: direct assignment
                  
                  int val = 42;
                  tss_set(key1, &val);            // May be undefined if key1 corrupted
                  return 0;
              }

          - compliant: |
              #include <threads.h>
              
              tss_t key1, key2;
              
              int worker(void *ignore) {
                  tss_create(&key1, NULL);        // Compliant: standard function
                  tss_create(&key2, NULL);        // Compliant: standard function
                  
                  int val = 42;
                  tss_set(key1, &val);            // Compliant: standard function
                  
                  int *retrieved = tss_get(key1); // Compliant: standard function
                  tss_delete(key1);               // Compliant: standard function
                  return 0;
              }

      - title: "Rule 22.13a. Thread objects shall have appropriate storage duration"
        description: |
          Objects of type thrd_t shall not have automatic storage duration nor thread storage duration.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using appropriate storage duration prevents undefined behavior from accessing thread objects outside their lifetime and ensures proper thread management.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              int worker(void *arg) {
                  return 0;
              }
              
              void func(void) {
                  thrd_t local_thread;            // Non-compliant: automatic storage
                  thrd_create(&local_thread, worker, NULL);
                  // Thread object may be accessed after function returns
              }

          - compliant: |
              #include <threads.h>
              
              static thrd_t thread_pool[10];      // Compliant: static storage
              
              int worker(void *arg) {
                  return 0;
              }
              
              void func(void) {
                  thrd_create(&thread_pool[0], worker, NULL);
                  // Thread object has static lifetime
              }

      - title: "Rule 22.13b. Mutex objects shall have appropriate storage duration"
        description: |
          Objects of type mtx_t shall not have automatic storage duration nor thread storage duration.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using appropriate storage duration prevents undefined behavior from accessing mutex objects outside their lifetime and ensures proper synchronization.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              int worker(void *ptr) {
                  mtx_t *mutex = (mtx_t*)ptr;
                  mtx_lock(mutex);                // May access invalid mutex
                  mtx_unlock(mutex);
                  return 0;
              }
              
              void func(void) {
                  mtx_t local_mutex;              // Non-compliant: automatic storage
                  mtx_init(&local_mutex, mtx_plain);
                  
                  thrd_t thread;
                  thrd_create(&thread, worker, &local_mutex);
                  // Thread may access local_mutex after function returns
              }

          - compliant: |
              #include <threads.h>
              
              static mtx_t mutex_pool[5];         // Compliant: static storage
              
              int worker(void *ptr) {
                  mtx_t *mutex = (mtx_t*)ptr;
                  mtx_lock(mutex);                // Safe access to static mutex
                  mtx_unlock(mutex);
                  return 0;
              }
              
              void func(void) {
                  mtx_init(&mutex_pool[0], mtx_plain);
                  
                  thrd_t thread;
                  thrd_create(&thread, worker, &mutex_pool[0]);
                  // Mutex object has static lifetime
              }

      - title: "Rule 22.13c. Condition variables shall have appropriate storage duration"
        description: |
          Objects of type cnd_t shall not have automatic storage duration nor thread storage duration.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using appropriate storage duration prevents undefined behavior from accessing condition variables outside their lifetime and ensures proper synchronization.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              static mtx_t global_mutex;
              
              int worker(void *ptr) {
                  cnd_t *cond = (cnd_t*)ptr;
                  mtx_lock(&global_mutex);
                  cnd_wait(cond, &global_mutex);  // May access invalid condition variable
                  mtx_unlock(&global_mutex);
                  return 0;
              }
              
              void func(void) {
                  cnd_t local_condition;          // Non-compliant: automatic storage
                  cnd_init(&local_condition);
                  
                  thrd_t thread;
                  thrd_create(&thread, worker, &local_condition);
                  // Thread may access local_condition after function returns
              }

          - compliant: |
              #include <threads.h>
              
              static mtx_t global_mutex;
              static cnd_t condition_pool[3];    // Compliant: static storage
              
              int worker(void *ptr) {
                  cnd_t *cond = (cnd_t*)ptr;
                  mtx_lock(&global_mutex);
                  cnd_wait(cond, &global_mutex);  // Safe access to static condition variable
                  mtx_unlock(&global_mutex);
                  return 0;
              }
              
              void func(void) {
                  cnd_init(&condition_pool[0]);
                  
                  thrd_t thread;
                  thrd_create(&thread, worker, &condition_pool[0]);
                  // Condition variable has static lifetime
              }

      - title: "Rule 22.13d. Thread-specific storage pointers shall have appropriate storage duration"
        description: |
          Objects of type tss_t shall not have automatic storage duration nor thread storage duration.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using appropriate storage duration prevents undefined behavior from accessing thread-specific storage outside their lifetime and ensures proper thread-local data management.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              int worker(void *ptr) {
                  tss_t *key = (tss_t*)ptr;
                  int value = 42;
                  tss_set(*key, &value);          // May access invalid TSS key
                  return 0;
              }
              
              void func(void) {
                  tss_t local_key;                // Non-compliant: automatic storage
                  tss_create(&local_key, NULL);
                  
                  thrd_t thread;
                  thrd_create(&thread, worker, &local_key);
                  // Thread may access local_key after function returns
              }

          - compliant: |
              #include <threads.h>
              
              static tss_t storage_keys[2];       // Compliant: static storage
              
              int worker(void *ptr) {
                  tss_t *key = (tss_t*)ptr;
                  int value = 42;
                  tss_set(*key, &value);          // Safe access to static TSS key
                  return 0;
              }
              
              void func(void) {
                  tss_create(&storage_keys[0], NULL);
                  
                  thrd_t thread;
                  thrd_create(&thread, worker, &storage_keys[0]);
                  // TSS key has static lifetime
              }

      - title: "Rule 22.14a. Mutex objects shall be initialized before being accessed"
        description: |
          Mutex objects shall be initialized by calling mtx_init() before any access operations.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Proper mutex initialization prevents undefined behavior from accessing uninitialized mutex objects and ensures deterministic thread synchronization.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              static mtx_t mutex1, mutex2;
              
              int worker1(void *ignore) {
                  mtx_init(&mutex2, mtx_plain);   // Non-compliant: worker2 may access first
                  mtx_lock(&mutex1);              // May access uninitialized mutex
                  mtx_unlock(&mutex1);
                  return 0;
              }
              
              int worker2(void *ignore) {
                  mtx_lock(&mutex2);              // May access uninitialized mutex
                  mtx_unlock(&mutex2);
                  return 0;
              }

          - compliant: |
              #include <threads.h>
              
              static mtx_t mutex1, mutex2;
              static thrd_t thread1, thread2;
              
              int worker1(void *ignore) {
                  mtx_lock(&mutex1);              // Compliant: initialized before threads
                  mtx_unlock(&mutex1);
                  return 0;
              }
              
              void main(void) {
                  mtx_init(&mutex1, mtx_plain);   // Compliant: initialize before threads
                  mtx_init(&mutex2, mtx_plain);
                  
                  thrd_create(&thread1, worker1, NULL);
                  thrd_create(&thread2, worker1, NULL);
              }

      - title: "Rule 22.14b. Condition variables shall be initialized before being accessed"
        description: |
          Condition variables shall be initialized by calling cnd_init() before any access operations.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Proper condition variable initialization prevents undefined behavior from accessing uninitialized condition variables and ensures deterministic thread synchronization.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              static cnd_t condition1, condition2;
              static mtx_t mutex;
              
              int worker1(void *ignore) {
                  cnd_init(&condition2);          // Non-compliant: worker2 may access first
                  
                  mtx_lock(&mutex);
                  cnd_wait(&condition1, &mutex);  // May access uninitialized condition variable
                  mtx_unlock(&mutex);
                  return 0;
              }
              
              int worker2(void *ignore) {
                  mtx_lock(&mutex);
                  cnd_wait(&condition2, &mutex);  // May access uninitialized condition variable
                  mtx_unlock(&mutex);
                  return 0;
              }

          - compliant: |
              #include <threads.h>
              
              static cnd_t condition1, condition2;
              static mtx_t mutex;
              static thrd_t thread1, thread2;
              
              int worker1(void *ignore) {
                  mtx_lock(&mutex);
                  cnd_wait(&condition1, &mutex);  // Compliant: initialized before threads
                  mtx_unlock(&mutex);
                  return 0;
              }
              
              void main(void) {
                  mtx_init(&mutex, mtx_plain);
                  cnd_init(&condition1);          // Compliant: initialize before threads
                  cnd_init(&condition2);
                  
                  thrd_create(&thread1, worker1, NULL);
                  thrd_create(&thread2, worker1, NULL);
              }

      - title: "Rule 22.15a. Mutex objects shall not be destroyed until after all threads accessing them have terminated"
        description: |
          Mutex objects shall only be destroyed by mtx_destroy() after all threads that access them have terminated.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Proper mutex destruction timing prevents undefined behavior from destroying mutexes still in use and ensures all threads complete safely.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              static mtx_t mutex;
              static thrd_t thread1, thread2;
              
              int worker1(void *ignore) {
                  mtx_lock(&mutex);
                  // Do work
                  mtx_unlock(&mutex);
                  return 0;
              }
              
              int worker2(void *ignore) {
                  mtx_lock(&mutex);
                  mtx_destroy(&mutex);            // Non-compliant: still in use
                  return 0;
              }

          - compliant: |
              #include <threads.h>
              
              static mtx_t mutex;
              static thrd_t thread1, thread2;
              
              int worker(void *ignore) {
                  mtx_lock(&mutex);
                  // Do work
                  mtx_unlock(&mutex);
                  return 0;
              }
              
              void main(void) {
                  mtx_init(&mutex, mtx_plain);
                  
                  thrd_create(&thread1, worker, NULL);
                  thrd_create(&thread2, worker, NULL);
                  
                  thrd_join(thread1, NULL);       // Wait for all threads
                  thrd_join(thread2, NULL);
                  
                  mtx_destroy(&mutex);            // Compliant: destroy after threads end
              }

      - title: "Rule 22.15b. Condition variables shall not be destroyed until after all threads accessing them have terminated"
        description: |
          Condition variables shall only be destroyed by cnd_destroy() after all threads that access them have terminated.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Proper condition variable destruction timing prevents undefined behavior from destroying condition variables with waiting threads and ensures all threads complete safely.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              static cnd_t condition;
              static mtx_t mutex;
              static thrd_t thread1, thread2;
              
              int worker1(void *ignore) {
                  mtx_lock(&mutex);
                  cnd_wait(&condition, &mutex);
                  mtx_unlock(&mutex);
                  return 0;
              }
              
              int worker2(void *ignore) {
                  cnd_destroy(&condition);        // Non-compliant: thread1 may be waiting
                  return 0;
              }

          - compliant: |
              #include <threads.h>
              
              static cnd_t condition;
              static mtx_t mutex;
              static thrd_t thread1, thread2;
              
              int worker(void *ignore) {
                  mtx_lock(&mutex);
                  cnd_wait(&condition, &mutex);
                  mtx_unlock(&mutex);
                  return 0;
              }
              
              void main(void) {
                  mtx_init(&mutex, mtx_plain);
                  cnd_init(&condition);
                  
                  thrd_create(&thread1, worker, NULL);
                  thrd_create(&thread2, worker, NULL);
                  
                  cnd_broadcast(&condition);      // Wake all waiting threads
                  thrd_join(thread1, NULL);       // Wait for all threads
                  thrd_join(thread2, NULL);
                  
                  cnd_destroy(&condition);        // Compliant: destroy after threads end
                  mtx_destroy(&mutex);
              }

      - title: "Rule 22.15c. Thread-specific storage shall not be deleted until after all threads accessing it have terminated"
        description: |
          Thread-specific storage shall only be deleted by tss_delete() after all threads that access it have terminated.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Proper thread-specific storage deletion timing prevents undefined behavior from deleting storage still in use and ensures all threads complete safely.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              static tss_t storage_key;
              static thrd_t thread1, thread2;
              
              int worker1(void *ignore) {
                  int value = 42;
                  tss_set(storage_key, &value);
                  tss_delete(storage_key);        // Non-compliant: thread2 may still access
                  return 0;
              }
              
              int worker2(void *ignore) {
                  int *value = tss_get(storage_key); // May access deleted storage
                  return 0;
              }

          - compliant: |
              #include <threads.h>
              
              static tss_t storage_key;
              static thrd_t thread1, thread2;
              
              int worker(void *ignore) {
                  int value = 42;
                  tss_set(storage_key, &value);   // Compliant: just using storage
                  return 0;
              }
              
              void main(void) {
                  tss_create(&storage_key, NULL);
                  
                  thrd_create(&thread1, worker, NULL);
                  thrd_create(&thread2, worker, NULL);
                  
                  thrd_join(thread1, NULL);       // Wait for all threads
                  thrd_join(thread2, NULL);
                  
                  tss_delete(storage_key);        // Compliant: delete after threads end
              }

      - title: "Rule 22.16. All mutex objects locked by a thread shall be explicitly unlocked by the same thread"
        description: |
          Every mutex locked by mtx_lock() shall have a corresponding mtx_unlock() on all code paths before the thread exits.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Explicit unlocking prevents deadlocks and ensures proper mutex lifecycle management, preventing undefined behavior from mutex destruction.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              #include <stdbool.h>
              
              static mtx_t mutex1, mutex2;
              
              int worker(void *ignore) {
                  bool condition = true;
                  
                  mtx_lock(&mutex1);
                  mtx_unlock(&mutex1);            // Compliant: proper unlock
                  
                  mtx_lock(&mutex2);              // Non-compliant: not unlocked on all paths
                  if (condition) {
                      mtx_unlock(&mutex2);        // Only unlocked in this branch
                  }
                  return 0;                       // Thread exits without unlock
              }

          - compliant: |
              #include <threads.h>
              #include <stdbool.h>
              
              static mtx_t mutex1, mutex2;
              
              int worker(void *ignore) {
                  bool condition = true;
                  
                  mtx_lock(&mutex1);
                  // Do work
                  mtx_unlock(&mutex1);            // Compliant: proper unlock
                  
                  mtx_lock(&mutex2);
                  if (condition) {
                      // Do conditional work
                      mtx_unlock(&mutex2);        // Unlock in this branch
                  } else {
                      // Do alternative work
                      mtx_unlock(&mutex2);        // Unlock in this branch too
                  }
                  return 0;                       // Compliant: unlocked on all paths
              }

      - title: "Rule 22.17a. No thread shall unlock a mutex it has not locked before"
        description: |
          Mutexes shall only be unlocked by the thread that locked them and shall not be unlocked multiple times.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Proper mutex ownership prevents undefined behavior from unlocking mutexes not owned by the calling thread and ensures correct synchronization.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              static mtx_t mutex1, mutex2;
              
              int thread1(void *ignore) {
                  mtx_lock(&mutex1);
                  mtx_unlock(&mutex1);            // Compliant: unlocking own lock
                  mtx_unlock(&mutex1);            // Non-compliant: unlocking unlocked mutex
                  
                  mtx_unlock(&mutex2);            // Non-compliant: not locked by this thread
                  return 0;
              }
              
              int thread2(void *ignore) {
                  mtx_lock(&mutex2);              // Different thread locks mutex2
                  // Work...
                  mtx_unlock(&mutex2);
                  return 0;
              }

          - compliant: |
              #include <threads.h>
              
              static mtx_t mutex1, mutex2;
              
              int thread1(void *ignore) {
                  mtx_lock(&mutex1);
                  // Do work
                  mtx_unlock(&mutex1);            // Compliant: unlocking own lock
                  return 0;
              }
              
              int thread2(void *ignore) {
                  mtx_lock(&mutex2);              // Each thread locks its own mutex
                  // Work...
                  mtx_unlock(&mutex2);            // Compliant: unlocking own lock
                  return 0;
              }

      - title: "Rule 22.17b. Condition wait functions shall only be called with mutexes locked by the calling thread"
        description: |
          Functions cnd_wait() and cnd_timedwait() shall only be called with a mutex that is currently locked by the calling thread.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Proper mutex state for condition waits prevents undefined behavior and ensures correct condition variable semantics according to the C Standard.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              static mtx_t mutex1;
              static cnd_t condition;
              
              int thread1(void *ignore) {
                  cnd_wait(&condition, &mutex1);  // Non-compliant: mutex not locked
                  
                  mtx_lock(&mutex1);
                  mtx_unlock(&mutex1);
                  cnd_wait(&condition, &mutex1);  // Non-compliant: mutex unlocked again
                  return 0;
              }

          - compliant: |
              #include <threads.h>
              
              static mtx_t mutex1;
              static cnd_t condition;
              
              int thread1(void *ignore) {
                  mtx_lock(&mutex1);
                  
                  // Wait with properly locked mutex
                  cnd_wait(&condition, &mutex1);  // Compliant: mutex locked by this thread
                  
                  mtx_unlock(&mutex1);            // Compliant: unlocking after wait
                  return 0;
              }
              
              int thread2(void *ignore) {
                  mtx_lock(&mutex1);
                  cnd_signal(&condition);         // Signal the condition
                  mtx_unlock(&mutex1);
                  return 0;
              }

      - title: "Rule 22.18. Non-recursive mutexes shall not be recursively locked"
        description: |
          Non-recursive mutexes shall only be locked once by a thread and must not be locked again by the same thread until unlocked.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Avoiding recursive locking on non-recursive mutexes prevents undefined behavior and potential deadlocks.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              static mtx_t plain_mutex;
              static mtx_t recursive_mutex;
              
              int worker(void *ignore) {
                  // Recursive mutex usage - OK
                  mtx_lock(&recursive_mutex);     // Compliant: first lock
                  mtx_lock(&recursive_mutex);     // Compliant: recursive mutex allows this
                  mtx_unlock(&recursive_mutex);
                  mtx_unlock(&recursive_mutex);
                  
                  // Non-recursive mutex usage - problematic
                  mtx_lock(&plain_mutex);         // Compliant: first lock
                  mtx_lock(&plain_mutex);         // Non-compliant: recursive lock on non-recursive mutex
                  mtx_unlock(&plain_mutex);
                  mtx_unlock(&plain_mutex);       // Non-compliant if reachable
                  return 0;
              }
              
              void main(void) {
                  mtx_init(&plain_mutex, mtx_plain);
                  mtx_init(&recursive_mutex, mtx_recursive);
              }

          - compliant: |
              #include <threads.h>
              
              static mtx_t plain_mutex;
              static mtx_t recursive_mutex;
              
              int worker(void *ignore) {
                  // Proper non-recursive mutex usage
                  mtx_lock(&plain_mutex);         // Compliant: single lock
                  // Do work
                  mtx_unlock(&plain_mutex);       // Compliant: single unlock
                  
                  // Proper recursive mutex usage
                  mtx_lock(&recursive_mutex);     // Compliant: first lock
                  mtx_lock(&recursive_mutex);     // Compliant: recursive allowed
                  mtx_unlock(&recursive_mutex);   // Unlock nested
                  mtx_unlock(&recursive_mutex);   // Unlock original
                  return 0;
              }

      - title: "Rule 22.19. A condition variable shall be associated with at most one mutex object"
        description: |
          Each condition variable shall be used consistently with the same mutex object across all threads to avoid undefined behavior.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Consistent mutex-condition association prevents undefined behavior when signaling condition variables and ensures predictable thread synchronization.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              static mtx_t mutex1, mutex2;
              static cnd_t shared_condition;
              
              int thread1(void *ignore) {
                  mtx_lock(&mutex1);
                  cnd_wait(&shared_condition, &mutex1);  // Non-compliant: using mutex1
                  mtx_unlock(&mutex1);
                  return 0;
              }
              
              int thread2(void *ignore) {
                  mtx_lock(&mutex2);
                  cnd_wait(&shared_condition, &mutex2);  // Non-compliant: using mutex2 with same condition
                  mtx_unlock(&mutex2);
                  return 0;
              }
              
              int thread3(void *ignore) {
                  cnd_signal(&shared_condition);          // Unclear which mutex will be affected
                  return 0;
              }

          - compliant: |
              #include <threads.h>
              
              static mtx_t shared_mutex;
              static cnd_t condition1, condition2;
              
              int thread1(void *ignore) {
                  mtx_lock(&shared_mutex);
                  cnd_wait(&condition1, &shared_mutex);   // Compliant: consistent mutex-condition pair
                  mtx_unlock(&shared_mutex);
                  return 0;
              }
              
              int thread2(void *ignore) {
                  mtx_lock(&shared_mutex);
                  cnd_wait(&condition2, &shared_mutex);   // Compliant: different condition, same mutex
                  mtx_unlock(&shared_mutex);
                  return 0;
              }
              
              int thread3(void *ignore) {
                  cnd_signal(&condition1);                // Compliant: clear which thread is signaled
                  return 0;
              }

      - title: "Rule 22.20. Thread-specific storage pointers shall be created before being accessed"
        description: |
          Thread-specific storage objects shall be explicitly created by tss_create() before any thread attempts to access them.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: other
        severity: mandatory
        impact: |
          Creating thread-specific storage before access prevents undefined behavior and ensures deterministic thread-local data management.
        code_examples:
          # C examples
          - non_compliant: |
              #include <threads.h>
              
              static tss_t storage_key1, storage_key2;
              static int global_data = 42;
              
              int thread1(void *ignore) {
                  tss_set(storage_key1, &global_data);   // Non-compliant: key1 may not be created yet
                  tss_set(storage_key2, &global_data);   // Compliant: key2 created before threads
                  return 0;
              }
              
              int thread2(void *ignore) {
                  tss_create(&storage_key1, NULL);       // Non-compliant: thread1 may access first
                  return 0;
              }
              
              void main(void) {
                  tss_create(&storage_key2, NULL);       // Compliant: created before threads
                  
                  thrd_t id1, id2;
                  thrd_create(&id1, thread1, NULL);
                  thrd_create(&id2, thread2, NULL);
              }

          - compliant: |
              #include <threads.h>
              
              static tss_t storage_key1, storage_key2;
              static int global_data1 = 42, global_data2 = 24;
              
              int thread1(void *ignore) {
                  tss_set(storage_key1, &global_data1);  // Compliant: key1 created before threads
                  
                  int *value = tss_get(storage_key1);    // Compliant: accessing created key
                  if (value) {
                      *value = 100;
                  }
                  return 0;
              }
              
              int thread2(void *ignore) {
                  tss_set(storage_key2, &global_data2);  // Compliant: key2 created before threads
                  return 0;
              }
              
              void main(void) {
                  tss_create(&storage_key1, NULL);       // Compliant: create before threads
                  tss_create(&storage_key2, NULL);       // Compliant: create before threads
                  
                  thrd_t id1, id2;
                  thrd_create(&id1, thread1, NULL);
                  thrd_create(&id2, thread2, NULL);
                  
                  thrd_join(id1, NULL);
                  thrd_join(id2, NULL);
                  
                  tss_delete(storage_key1);
                  tss_delete(storage_key2);
              }

  - name: "5.23. Generic selections"
    paths:
      - '**/*.c'
      - '**/*.h'
    policies:
      - title: "Rule 23.1a. A generic selection should only be expanded from a function-like macro"
        description: |
          Generic selection expressions should be implemented within function-like macros rather than used directly in code.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Using generic selections in macros enables true generic programming where the operand type varies, rather than redundant type checking of known types.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdint.h>
              
              void func(void) {
                  int32_t x = 0;
                  
                  // Non-compliant: direct generic selection, type already known
                  int32_t y = _Generic(x,
                      int32_t: 1,
                      float: 2);
              }

          - compliant: |
              #include <stdint.h>
              
              // Compliant: generic selection implemented within a macro
              #define type_size(X) _Generic((X), \
                  int32_t: sizeof(int32_t), \
                  float: sizeof(float), \
                  default: sizeof(void*))
              
              void func(void) {
                  int32_t x = 0;
                  size_t size = type_size(x); // Uses macro with generic selection
              }

      - title: "Rule 23.1b. A generic selection controlling expression should be derived from macro arguments"
        description: |
          When generic selections are used in macros, the controlling expression should be derived from one of the macro's arguments.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Deriving the controlling expression from macro arguments ensures the generic selection provides meaningful type discrimination based on caller context.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdint.h>
              
              int32_t x = 0;
              
              // Non-compliant: controlling expression not from macro argument
              #define maybe_inc(Y) (_Generic(x, \
                  int32_t: 1, \
                  default: 0) + (Y))
              
              void func(void) {
                  int result = maybe_inc(5);
              }

          - compliant: |
              #include <stdint.h>
              
              // Function declarations
              int handle_int32(int32_t value);
              int handle_float(float value);
              int handle_any(int value);
              
              // Compliant: controlling expression derived from macro argument
              #define arith(X) (_Generic((X), \
                  int32_t: handle_int32, \
                  float: handle_float, \
                  default: handle_any)(X))
              
              void func(void) {
                  int32_t x = 0;
                  float f = 1.0f;
                  
                  int result1 = arith(x);     // Uses int32_t handler
                  int result2 = arith(f);     // Uses float handler
              }

      - title: "Rule 23.2. A generic selection that is not expanded from a macro shall not contain potential side effects in the controlling expression"
        description: |
          Controlling expressions in generic selections shall not contain side effects when not used within macros.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding side effects in controlling expressions prevents misleading code where apparent operations are not executed, ensuring predictable behavior.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdint.h>
              
              int32_t shared_state = 0;
              
              int some_function(void) {
                  return 42;
              }
              
              void func(void) {
                  // Non-compliant: side effect in controlling expression
                  int result1 = _Generic(++shared_state,
                      int32_t: 0,
                      default: 1);
                  
                  // Non-compliant: function call side effect
                  int result2 = _Generic(some_function(),
                      int32_t: 100,
                      default: 200);
                  
                  // shared_state is NOT incremented, some_function() is NOT called
              }

          - compliant: |
              #include <stdint.h>
              
              typedef int64_t STATE;
              STATE shared_state = 0;
              
              void func(void) {
                  // Compliant: no side effects in controlling expression
                  _Static_assert(_Generic(shared_state,
                      int32_t: 0,
                      default: 1),
                      "error on wrong type");
                  
                  // Compliant: variable reference without modification
                  int result = _Generic(shared_state,
                      int64_t: 64,
                      int32_t: 32,
                      default: 0);
                  
                  // If side effects are needed, perform them separately
                  shared_state++;  // Actual side effect performed explicitly
              }

      - title: "Rule 23.3. A generic selection should contain at least one non-default association"
        description: |
          Generic selections should include at least one explicit type association in addition to any default association.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Including explicit type associations makes generic selections meaningful and enables intentional type constraint violations when types don't match.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdint.h>
              
              // Non-compliant: only default association, no type checking
              #define no_op(X) _Generic((X), default: (X))
              
              void func(void) {
                  int32_t x = 5;
                  float f = 3.14f;
                  
                  // These both work but provide no type safety
                  int32_t result1 = no_op(x);
                  float result2 = no_op(f);
              }

          - compliant: |
              #include <stdint.h>
              
              // Function declarations
              int handle_int(int32_t value);
              int handle_numeric_value(int value);
              int handle_int32(int32_t value);
              int handle_uint32(uint32_t value);
              
              // Compliant: has non-default and default associations
              #define filter_ints(X) (_Generic((X), \
                  int32_t: handle_int, \
                  default: handle_numeric_value)(X))
              
              // Compliant: has multiple non-default associations
              #define only_ints(X) (_Generic((X), \
                  int32_t: handle_int32, \
                  uint32_t: handle_uint32)(X))
              
              // Compliant: single type constraint, intentional constraint violation
              #define require_char(X) (_Generic((X), char: (X)))
              
              void func(void) {
                  int32_t x = 5;
                  uint32_t y = 10u;
                  char c = 'A';
                  
                  int result1 = filter_ints(x);  // Uses int32_t handler
                  int result2 = only_ints(y);    // Uses uint32_t handler
                  char result3 = require_char(c); // Type constraint satisfied
                  
                  // require_char(x) would cause constraint violation - intended behavior
              }

      - title: "Rule 23.4. A generic association shall list an appropriate type"
        description: |
          Generic associations shall not list types that can never match after value conversion.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Avoiding inappropriate type associations prevents useless code and likely errors, as value conversion removes qualifications and decays arrays/functions to pointers.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdint.h>
              
              // Function declarations
              void handle_funcp(void* ptr);
              void handle_intp(int32_t* ptr);
              void handle_const_intp(const int32_t* ptr);
              void handle_other_value(void* ptr);
              
              typedef int32_t Func(int);
              typedef int32_t Array[10];
              typedef int32_t const CInt;
              
              // Non-compliant: function type can never match
              #define handle_function_nc(X) _Generic((X), \
                  Func: handle_funcp(&(X)), \
                  Func*: handle_funcp(X))
              
              // Non-compliant: array type can never match
              #define handle_array_nc(X) _Generic((X), \
                  Array: handle_intp((X) + 0), \
                  int32_t*: handle_intp(X))
              
              // Non-compliant: const-qualified type at object level
              #define filter_const_nc(X) _Generic((X), \
                  CInt: handle_const_intp, \
                  default: handle_other_value)

          - compliant: |
              #include <stdint.h>
              
              // Function declarations
              void handle_funcp(void* ptr);
              void handle_intp(int32_t* ptr);
              void handle_const_intp(const int32_t* ptr);
              void handle_other_value(void* ptr);
              
              typedef int32_t Func(int);
              typedef int32_t Array[10];
              typedef Func* FuncP;
              typedef Array* ArrayP;
              typedef int32_t const CInt;
              
              // Compliant: only function pointer types
              #define handle_function(X) _Generic((X), FuncP: handle_funcp(X))
              
              // Compliant: using address to create pointer type
              #define handle_array(X) _Generic(&(X)[0], \
                  int32_t*: handle_intp(X), \
                  ArrayP: handle_intp(*(X)))
              
              // Compliant: qualification on pointed-to type
              #define filter_const(X) _Generic((X), \
                  CInt*: handle_const_intp, \
                  int32_t*: handle_intp, \
                  default: handle_other_value)

      - title: "Rule 23.5. A generic selection should not depend on implicit pointer type conversion"
        description: |
          Generic selections shall not rely on implicit pointer conversions that would occur in other contexts.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Preventing reliance on implicit conversions ensures predictable generic selection behavior and avoids unexpected fallthrough to default associations.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdint.h>
              
              void handle_cpi(const int32_t*);
              void handle_any(void*);
              
              // Non-compliant: int32_t* falls to default, not const int32_t*
              #define handle_pointer1(X) _Generic((X), \
                  const int32_t*: handle_cpi, \
                  default: handle_any)
              
              // Non-compliant: int32_t* falls to default, not void*
              #define handle_pointer2(X) _Generic((X), \
                  void*: handle_any, \
                  const int32_t*: handle_cpi, \
                  default: handle_any)
              
              void func(void) {
                  int32_t mi = 0;
                  handle_pointer1(&mi);  // Uses default, not const int32_t*
                  handle_pointer2(&mi);  // Uses default, not void* or const int32_t*
              }

          - compliant: |
              #include <stdint.h>
              
              void handle_unq(void*);
              void handle_cq(void const*);
              void handle_vq(void volatile*);
              void handle_cvq(void const volatile*);
              
              // Compliant: explicit conversion to handle qualification
              #define handle_pointer(X) _Generic(1 ? (X) : (void*)(X), \
                  void*: handle_unq, \
                  void const*: handle_cq, \
                  void volatile*: handle_vq, \
                  void const volatile*: handle_cvq)
              
              // Compliant: explicit associations for expected types
              #define handle_int_ptrs(X) _Generic((X), \
                  int32_t*: handle_unq, \
                  const int32_t*: handle_cq, \
                  default: handle_unq)
              
              void func(void) {
                  int32_t mi = 0;
                  const int32_t ci = 0;
                  handle_pointer(&mi);      // Matches void*
                  handle_int_ptrs(&mi);     // Matches int32_t*
                  handle_int_ptrs(&ci);     // Matches const int32_t*
              }

      - title: "Rule 23.6. The controlling expression of a generic selection shall have an essential type that matches its standard type"
        description: |
          The controlling expression of a generic selection shall have consistent essential and standard types, except for non-character, non-boolean integer constant expressions of lower rank than int.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Ensuring type consistency maintains alignment with the essential type system and prevents unexpected association selection based on standard type promotion.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdint.h>
              #include <stdbool.h>
              
              // Function declarations
              int handle_sshort(short value);
              int handle_sint(int value);
              int handle_uint(unsigned int value);
              int handle_any(int value);
              
              enum Status { IDLE = 0, RUNNING = 1, STOPPED = 2 };
              
              #define filter_ints(X) _Generic((X), \
                  signed short: handle_sshort, \
                  signed int: handle_sint, \
                  unsigned int: handle_uint, \
                  default: handle_any)
              
              void func(void) {
                  short s16 = 0;
                  enum Status status = IDLE;
                  
                  // Non-compliant: s16 + s16 has standard type int, essential type short
                  filter_ints(s16 + s16);
                  
                  // Non-compliant: 'c' has standard type int, essential type char
                  filter_ints('c');
                  
                  // Non-compliant: enum has standard underlying type, essential enum type
                  filter_ints(status);
                  filter_ints(RUNNING);
              }

          - compliant: |
              #include <stdint.h>
              
              // Function declarations
              int handle_sshort(short value);
              int handle_sint(int value);
              int handle_uint(unsigned int value);
              int handle_slong(long value);
              int handle_any(int value);
              
              #define filter_ints(X) _Generic((X), \
                  signed short: handle_sshort, \
                  signed int: handle_sint, \
                  unsigned int: handle_uint, \
                  signed long: handle_slong, \
                  default: handle_any)
              
              void func(void) {
                  short s16 = 0;
                  int i32 = 0;
                  long l32 = 0;
                  
                  // Compliant: direct variable usage, types match
                  filter_ints(s16);
                  filter_ints(i32);
                  filter_ints(l32);
                  
                  // Compliant: integer constants (exception applies)
                  filter_ints(10u);        // Type of Lowest Rank: unsigned char, but exception applies
                  filter_ints(250 + 350);  // Standard Type of Lowest Rank: signed short, but exception applies
              }

      - title: "Rule 23.7. A generic selection that is expanded from a macro should evaluate its argument only once"
        description: |
          Macro arguments used in generic selections should be evaluated exactly once consistently across all associations, regardless of which association is selected.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Consistent argument evaluation prevents side effects from being lost or duplicated unpredictably based on association selection, ensuring reliable macro behavior.
        code_examples:
          # C examples
          - non_compliant: |
              #include <stdint.h>
              
              float fun3f(float x);
              double fun3(double x);
              int default_result = 42;
              
              // Non-compliant: argument evaluation depends on association selection
              #define gfun3(X) _Generic((X), \
                  float: fun3f(X), \
                  double: fun3(X), \
                  default: default_result)
              
              void func(void) {
                  int counter = 0;
                  
                  // X is evaluated in float/double cases but not default case
                  int result1 = gfun3((float)++counter);  // counter incremented
                  int result2 = gfun3(++counter);         // counter NOT incremented
              }

          - compliant: |
              #include <stdint.h>
              
              float fun1f(float x);
              double fun1(double x);
              long double fun1l(long double x);
              float fun2f(float x);
              double fun2(double x);
              long double fun2l(long double x);
              
              // Compliant: argument evaluated once outside generic selection
              #define gfun1(X) (_Generic((X), \
                  float: fun1f, \
                  double: fun1, \
                  default: fun1l)(X))
              
              // Compliant: argument evaluated once in each association
              #define gfun2(X) _Generic((X), \
                  float: fun2f(X), \
                  double: fun2(X), \
                  default: fun2l(X))
              
              // Compliant: exception for constant expressions
              #define is_pointer_const(P) _Generic(1 ? (P) : (void*)(P), \
                  void const*: 1, \
                  void const volatile*: 1, \
                  default: 0)

      - title: "Rule 23.8. A default association shall appear as either the first or the last association of a generic selection"
        description: |
          Default associations shall be positioned as either the first or last association in the list.
        software_version: "MISRA C:2025"
        reference_link: https://www.misra.org.uk
        required_context: single-file
        severity: mandatory
        impact: |
          Consistent positioning of default associations makes generic selections easier to read and understand by establishing clear structural conventions.
        code_examples:
          # C examples
          - non_compliant: |
              #include <math.h>
              
              // Non-compliant: default association in middle position
              #define sqrt_generic(X) (_Generic((X), \
                  float: sqrtf, \
                  default: sqrt, \
                  double: sqrtd)(X))
              
              void func(void) {
                  float f = 4.0f;
                  double d = 16.0;
                  long double ld = 25.0L;
                  
                  float result1 = sqrt_generic(f);   // Uses sqrtf
                  double result2 = sqrt_generic(d);  // Uses sqrtd  
                  long double result3 = sqrt_generic(ld); // Uses sqrt (default)
              }

          - compliant: |
              #include <math.h>
              
              // Compliant: default association is first
              #define cbrt_generic(X) (_Generic((X), \
                  default: cbrt, \
                  float: cbrtf, \
                  double: cbrtd)(X))
              
              // Compliant: default association is last
              #define pow_generic(X, Y) (_Generic((X), \
                  float: powf, \
                  double: pow, \
                  default: powl)(X, Y))
              
              // Compliant: no default association
              #define handle_ptr(X) (_Generic((X), \
                  void*: handle_unqualified, \
                  void const*: handle_const, \
                  void volatile*: handle_volatile, \
                  void const volatile*: handle_cv)(X))

